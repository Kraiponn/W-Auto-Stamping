CCS PCH C Compiler, Version 4.049, 22135               17-Á.¤.-13 10:49

               Filename: E:\Work NCTC\Window\Stamping New Ver(28-08-2012)\main.lst

               ROM used: 18724 bytes (14%)
                         Largest free fragment is 65536
               RAM used: 94 (2%) at main() level
                         181 (5%) worst case
               Stack:    12 worst case (10 in main + 2 for interrupts)

*
00000:  GOTO   47E4
*
00008:  MOVWF  05
0000A:  MOVFF  FD8,06
0000E:  MOVFF  FE0,07
00012:  MOVLB  0
00014:  MOVFF  FE9,0D
00018:  MOVFF  FEA,08
0001C:  MOVFF  FE1,09
00020:  MOVFF  FE2,0A
00024:  MOVFF  FD9,0B
00028:  MOVFF  FDA,0C
0002C:  MOVFF  FF3,14
00030:  MOVFF  FF4,15
00034:  MOVFF  FFA,16
00038:  MOVFF  FFB,17
0003C:  MOVFF  00,0F
00040:  MOVFF  01,10
00044:  MOVFF  02,11
00048:  MOVFF  03,12
0004C:  MOVFF  04,13
00050:  BTFSS  F9D.5
00052:  GOTO   005C
00056:  BTFSC  F9E.5
00058:  GOTO   0B1A
0005C:  BTFSS  FA3.5
0005E:  GOTO   0068
00062:  BTFSC  FA4.5
00064:  GOTO   0B88
00068:  BTFSS  FF2.5
0006A:  GOTO   0074
0006E:  BTFSC  FF2.2
00070:  GOTO   0BF8
00074:  BTFSS  FF2.4
00076:  GOTO   0080
0007A:  BTFSC  FF2.1
0007C:  GOTO   0C0C
00080:  MOVFF  0F,00
00084:  MOVFF  10,01
00088:  MOVFF  11,02
0008C:  MOVFF  12,03
00090:  MOVFF  13,04
00094:  BSF    0E.7
00096:  MOVFF  0D,FE9
0009A:  MOVFF  08,FEA
0009E:  MOVFF  09,FE1
000A2:  MOVFF  0A,FE2
000A6:  MOVFF  0B,FD9
000AA:  MOVFF  0C,FDA
000AE:  MOVFF  14,FF3
000B2:  MOVFF  15,FF4
000B6:  MOVFF  16,FFA
000BA:  MOVFF  17,FFB
000BE:  MOVF   05,W
000C0:  MOVFF  07,FE0
000C4:  MOVFF  06,FD8
000C8:  RETFIE 0
.................... /******************************************************************************\ 
.................... |  Programming   : Auto Check And Stamping in AFE-3032 V1.2.2                  | 
.................... |  Describetion  : Chech Coils & Screw, At last Stamping Shutter               | 
.................... |  Complier      : CCS C V4.049.                                               | 
.................... |  MCU           : PIC18F8720 X-TAL 10 MHz.                                    | 
.................... |  CirCuit Board : COPAL-PLC                                                   | 
.................... |  Date          : 28/08/2012.                                                 | 
.................... /******************************************************************************\  
.................... |>>>>>>>>>>>>>   Command for Request data from function tester    <<<<<<<<<<<<<< 
.................... |  Format Coils Resistance Data -> [R1xx.xx,OK,R2xx.xx,OK] 
.................... |  COIL SPECIFICATION :----------- 
....................    | Coil1-2       : 102(+-10) Ohm 
....................    | Coil Rotor(3) : 13(+-1.3) Ohm 
....................    |------------------------------ 
.................... |   
.................... |   
.................... |    
.................... |    
.................... /*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/   
....................  
.................... #include "main.h" 
.................... #include <18F8720.h> 
.................... //////// Standard Header file for the PIC18F8720 device //////////////// 
.................... #device PIC18F8720 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                       //High speed osc with HW enabled 4X PLL 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOOSCSEN                 //Oscillator switching is disabled, main oscillator is source 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV45                   //Brownout reset at 4.5V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWAIT                   //Wait selections unavailable for Table Reads or Table Writes 
.................... #FUSES MCU                      //Microcontroller Mode 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
....................  
.................... #use delay(clock = 40000000) 
*
00C22:  CLRF   FEA
00C24:  MOVLW  9A
00C26:  MOVWF  FE9
00C28:  MOVF   FEF,W
00C2A:  BZ    0C48
00C2C:  MOVLW  0C
00C2E:  MOVWF  01
00C30:  CLRF   00
00C32:  DECFSZ 00,F
00C34:  BRA    0C32
00C36:  DECFSZ 01,F
00C38:  BRA    0C30
00C3A:  MOVLW  F7
00C3C:  MOVWF  00
00C3E:  DECFSZ 00,F
00C40:  BRA    0C3E
00C42:  BRA    0C44
00C44:  DECFSZ FEF,F
00C46:  BRA    0C2C
00C48:  RETLW  00
*
00C76:  MOVLW  02
00C78:  SUBWF  xA1,F
00C7A:  BNC   0C92
00C7C:  CLRF   FEA
00C7E:  MOVLW  A1
00C80:  MOVWF  FE9
00C82:  MOVF   FEF,W
00C84:  BZ    0C92
00C86:  MOVLW  02
00C88:  MOVWF  00
00C8A:  DECFSZ 00,F
00C8C:  BRA    0C8A
00C8E:  DECFSZ FEF,F
00C90:  BRA    0C86
00C92:  GOTO   0CA2 (RETURN)
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... //#use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
....................  
.................... #define Tx1         PIN_C6  //-- Pin interface Computer 
.................... #define Rx1         PIN_C7   
.................... #define Tx2         PIN_G1   
.................... #define Rx2         PIN_G2 
.................... #define SPD_115200  115200 
.................... #define SPD_38400   38400 
.................... #define SPD_19200   19200 
.................... #define SPD_9600    9600 
.................... #define SW_ID       0x70 
....................  
.................... //****************************************************************************** 
.................... //    OUTPUT DEFINE 
.................... #define RELAY      PIN_A3 
.................... #define TRIG       PIN_C0 
....................  
.................... #define SV_SLIDER  PIN_D0 
.................... #define SV_LOCK    PIN_D1 
.................... #define SV_STAMP   PIN_D2 
.................... #define SV_QR      PIN_D3  
.................... #define SV_COILS   PIN_D4 
.................... #define SV_SCREW   PIN_D5    
....................  
.................... #define LED_START  PIN_D7 
.................... #define BUZZER     PIN_E1 
.................... #define LEDG       PIN_E2 
.................... #define LEDR       PIN_E3 
....................  
.................... //****************************************************************************** 
.................... //    INPUT DEFINE 
.................... #define SW_RES         PIN_B0   
.................... #define SW_START       PIN_B1      
.................... #define SS_LOCK        PIN_B2 
....................  
.................... #define SS_UNLOCK      PIN_B3    
.................... #define SS_STAMP_DOWN  PIN_B4 
.................... #define SS_STAMP_UP    PIN_B5      
.................... #define SS_QR_DOWN     PIN_C1    
.................... #define SS_QR_UP       PIN_C2 
.................... #define SS_COIL_UP     PIN_G0      
.................... #define SS_COIL_DOWN   PIN_E7 
.................... #define SS_SCREW_UP    PIN_G3      
.................... #define SS_SCREW_DOWN  PIN_G4 
.................... #define SS_L           PIN_F0   
.................... #define SS_R           PIN_F1  
.................... #define SS_SCREW1      PIN_F2         
.................... #define SS_SCREW2      PIN_F3      
.................... #define SS_SCREW3      PIN_F4         
.................... #define SS_SCREW4      PIN_F5   
....................  
....................  
.................... #include <lcd_16char_2or4_line.c>  
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     x0  Not usage 
.................... //     x1  rs 
.................... //     x2  rw 
.................... //     x3  enable 
.................... //     x4  D4 
.................... //     x5  D5 
.................... //     x6  D6 
.................... //     x7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
.................... //************************************************************************ 
....................  
.................... struct lcd_pin_map { 
....................          BOOLEAN unused; 
....................          BOOLEAN  rs; 
....................          BOOLEAN  rw; 
....................          BOOLEAN  enable; 
....................          int      data : 4; 
....................   } lcd; 
....................    
....................   #byte lcd  = 0xF87 
....................   #define set_tris_lcd(x)   set_tris_h(x) 
....................  
....................   #define lcd_type 2              // 0=5x7 1 line, 1=5x10 1 line, 2=5x7 2 line 
....................   #define lcd_First_Line   0x00     // LCD RAM address for the first line 
....................   #define lcd_Second_Line  0x40     // LCD RAM address for the second line 
....................   #define lcd_Third_Line   0x14     // LCD RAM address for the third line 
....................   #define lcd_Forth_Line   0x54     // LCD RAM address for the forth line 
....................  
....................   byte const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0x0c, 1, 6}; 
....................   // Initial LCD 
....................  
....................  struct lcd_pin_map const LCD_WRITE = {0, 0, 0, 0}; 
....................  //struct lcd_pin_map const LCD_READ = {0, 0, 0, 15};   // 15 =  1111 
....................  // Setting the I/O port direction register. 
....................  
....................  void lcd_send_nibble( byte n )  
....................  { 
....................        lcd.data = n; 
*
00C56:  SWAPF  xA1,W
00C58:  ANDLW  F0
00C5A:  MOVWF  00
00C5C:  MOVLW  0F
00C5E:  ANDWF  F87,W
00C60:  IORWF  00,W
00C62:  MOVWF  F87
....................        delay_cycles(1); 
00C64:  NOP   
....................        //lcd.enable = 1; 
....................        output_high(PIN_H3); 
00C66:  BSF    F90.3
....................        delay_us(2); 
00C68:  MOVLW  06
00C6A:  MOVWF  00
00C6C:  DECFSZ 00,F
00C6E:  BRA    0C6C
00C70:  NOP   
....................        //lcd.enable = 0; 
....................        output_low(PIN_H3); 
00C72:  BCF    F90.3
....................  } 
00C74:  RETLW  00
....................  
....................  void lcd_send_byte( byte address, byte n)  
....................  { 
....................        lcd.rs = 0; 
*
00C96:  BCF    F87.1
....................        delay_us(500); 
00C98:  MOVLW  02
00C9A:  MOVWF  xA0
00C9C:  MOVLW  FA
00C9E:  MOVWF  xA1
00CA0:  BRA    0C76
00CA2:  DECFSZ xA0,F
00CA4:  BRA    0C9C
....................        lcd.rs = address; 
00CA6:  BTFSS  x9E.0
00CA8:  BCF    F87.1
00CAA:  BTFSC  x9E.0
00CAC:  BSF    F87.1
....................        delay_cycles(1); 
00CAE:  NOP   
....................        //lcd.enable = 0; 
....................        output_low(PIN_H3); 
00CB0:  BCF    F90.3
....................        lcd_send_nibble(n >> 4); 
00CB2:  SWAPF  x9F,W
00CB4:  MOVWF  xA0
00CB6:  MOVLW  0F
00CB8:  ANDWF  xA0,F
00CBA:  MOVFF  A0,A1
00CBE:  RCALL  0C56
....................        lcd_send_nibble(n & 0x0f); 
00CC0:  MOVF   x9F,W
00CC2:  ANDLW  0F
00CC4:  MOVWF  xA0
00CC6:  MOVWF  xA1
00CC8:  RCALL  0C56
....................  } 
00CCA:  RETLW  00
....................  
....................  void lcd_gotoxy( byte x, byte y)  
....................  { 
....................     byte address; 
....................            
....................        switch(y) 
....................         { 
*
00E36:  MOVLW  01
00E38:  SUBWF  x9B,W
00E3A:  ADDLW  FC
00E3C:  BC    0E5A
00E3E:  ADDLW  04
00E40:  GOTO   0E6E
....................             case 1: address = lcd_First_Line; 
00E44:  CLRF   x9C
....................             break; 
00E46:  BRA    0E5A
....................             case 2: address = lcd_Second_Line; 
00E48:  MOVLW  40
00E4A:  MOVWF  x9C
....................             break; 
00E4C:  BRA    0E5A
....................             case 3: address = lcd_Third_Line; 
00E4E:  MOVLW  14
00E50:  MOVWF  x9C
....................             break; 
00E52:  BRA    0E5A
....................             case 4: address = lcd_Forth_Line; 
00E54:  MOVLW  54
00E56:  MOVWF  x9C
....................             break; 
00E58:  BRA    0E5A
....................         } 
....................        address += x-1; 
00E5A:  MOVLW  01
00E5C:  SUBWF  x9A,W
00E5E:  ADDWF  x9C,F
....................        lcd_send_byte(0,0x80|address); 
00E60:  MOVF   x9C,W
00E62:  IORLW  80
00E64:  MOVWF  x9D
00E66:  CLRF   x9E
00E68:  MOVWF  x9F
00E6A:  RCALL  0C96
....................  } 
00E6C:  RETLW  00
....................  
....................  void lcd_init()  
....................  { 
....................        byte i; 
....................        set_tris_lcd(LCD_WRITE); 
*
00CCC:  MOVLW  00
00CCE:  MOVWF  F99
....................        lcd.rs = 0; 
00CD0:  BCF    F87.1
....................        //lcd. enable = 0; 
....................        output_low(PIN_H3); 
00CD2:  BCF    F90.3
....................        delay_ms(15); 
00CD4:  MOVLW  0F
00CD6:  MOVWF  x9A
00CD8:  RCALL  0C22
....................        for (i=1; i<=3; ++i) { 
00CDA:  MOVLW  01
00CDC:  MOVWF  5D
00CDE:  MOVF   5D,W
00CE0:  SUBLW  03
00CE2:  BNC   0CF4
....................            lcd_send_nibble(3); 
00CE4:  MOVLW  03
00CE6:  MOVWF  xA1
00CE8:  RCALL  0C56
....................            delay_ms(5); 
00CEA:  MOVLW  05
00CEC:  MOVWF  x9A
00CEE:  RCALL  0C22
....................        } 
00CF0:  INCF   5D,F
00CF2:  BRA    0CDE
....................        lcd_send_nibble(2); 
00CF4:  MOVLW  02
00CF6:  MOVWF  xA1
00CF8:  RCALL  0C56
....................        for (i=0; i<=3; ++i) 
00CFA:  CLRF   5D
00CFC:  MOVF   5D,W
00CFE:  SUBLW  03
00D00:  BNC   0D20
....................            lcd_send_byte(0,LCD_INIT_STRING[i]); 
00D02:  CLRF   03
00D04:  MOVF   5D,W
00D06:  MOVFF  FF2,5E
00D0A:  BCF    FF2.7
00D0C:  CALL   00CA
00D10:  BTFSC  5E.7
00D12:  BSF    FF2.7
00D14:  MOVWF  5F
00D16:  CLRF   x9E
00D18:  MOVWF  x9F
00D1A:  RCALL  0C96
00D1C:  INCF   5D,F
00D1E:  BRA    0CFC
....................  } 
00D20:  GOTO   0D68 (RETURN)
....................  
....................  void lcd_putc( char c )  
....................  { 
....................     switch (c)  
....................        { 
*
00EA0:  MOVF   x99,W
00EA2:  XORLW  0C
00EA4:  BZ    0EB0
00EA6:  XORLW  06
00EA8:  BZ    0EC0
00EAA:  XORLW  02
00EAC:  BZ    0ECC
00EAE:  BRA    0ED6
....................           case '\f'   : lcd_send_byte(0, 1); 
00EB0:  CLRF   x9E
00EB2:  MOVLW  01
00EB4:  MOVWF  x9F
00EB6:  RCALL  0C96
....................                         delay_ms(2);            break; 
00EB8:  MOVLW  02
00EBA:  MOVWF  x9A
00EBC:  RCALL  0C22
00EBE:  BRA    0EE2
....................           case '\n'   : lcd_gotoxy(1,2);        break; 
00EC0:  MOVLW  01
00EC2:  MOVWF  x9A
00EC4:  MOVLW  02
00EC6:  MOVWF  x9B
00EC8:  RCALL  0E36
00ECA:  BRA    0EE2
....................           case '\b'   : lcd_send_byte(0,0x10);  break; 
00ECC:  CLRF   x9E
00ECE:  MOVLW  10
00ED0:  MOVWF  x9F
00ED2:  RCALL  0C96
00ED4:  BRA    0EE2
....................           //case '\m'   : lcd_gotoxy(9,2);        break; 
....................           default     : lcd_send_byte(1,c);     break; 
00ED6:  MOVLW  01
00ED8:  MOVWF  x9E
00EDA:  MOVFF  99,9F
00EDE:  RCALL  0C96
00EE0:  BRA    0EE2
....................        } 
....................  } 
00EE2:  RETLW  00
....................  
....................                                                          
.................... #use rs232(baud = SPD_19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
.................... #use i2c(Master,Fast,sda = PIN_C4,scl = PIN_C3) 
*
00FF4:  MOVLW  08
00FF6:  MOVWF  01
00FF8:  BRA    0FFA
00FFA:  BRA    0FFC
00FFC:  BCF    F8B.3
00FFE:  BCF    F94.3
01000:  BRA    1002
01002:  BRA    1004
01004:  NOP   
01006:  RLCF   x61,F
01008:  BCF    F8B.4
0100A:  BTFSC  FD8.0
0100C:  BSF    F94.4
0100E:  BTFSS  FD8.0
01010:  BCF    F94.4
01012:  BSF    F94.3
01014:  BTFSS  F82.3
01016:  BRA    1014
01018:  DECFSZ 01,F
0101A:  BRA    0FF8
0101C:  BRA    101E
0101E:  BRA    1020
01020:  BCF    F8B.3
01022:  BCF    F94.3
01024:  NOP   
01026:  BSF    F94.4
01028:  BRA    102A
0102A:  BRA    102C
0102C:  NOP   
0102E:  BRA    1030
01030:  BRA    1032
01032:  NOP   
01034:  BSF    F94.3
01036:  BTFSS  F82.3
01038:  BRA    1036
0103A:  CLRF   01
0103C:  BRA    103E
0103E:  BRA    1040
01040:  NOP   
01042:  BTFSC  F82.4
01044:  BSF    01.0
01046:  BCF    F8B.3
01048:  BCF    F94.3
0104A:  BCF    F8B.4
0104C:  BCF    F94.4
0104E:  GOTO   10D0 (RETURN)
01052:  MOVLW  08
01054:  MOVWF  x61
01056:  MOVFF  00,62
0105A:  BSF    F94.4
0105C:  BRA    105E
0105E:  BRA    1060
01060:  NOP   
01062:  BSF    F94.3
01064:  BTFSS  F82.3
01066:  BRA    1064
01068:  BTFSC  F82.4
0106A:  BSF    FD8.0
0106C:  BTFSS  F82.4
0106E:  BCF    FD8.0
01070:  RLCF   01,F
01072:  BRA    1074
01074:  BRA    1076
01076:  BCF    F94.3
01078:  BCF    F8B.3
0107A:  DECFSZ x61,F
0107C:  BRA    105A
0107E:  BSF    F94.4
01080:  BRA    1082
01082:  BRA    1084
01084:  NOP   
01086:  BCF    F8B.4
01088:  MOVF   x62,W
0108A:  BTFSS  FD8.2
0108C:  BCF    F94.4
0108E:  NOP   
01090:  BSF    F94.3
01092:  BTFSS  F82.3
01094:  BRA    1092
01096:  BRA    1098
01098:  BRA    109A
0109A:  BCF    F8B.3
0109C:  BCF    F94.3
0109E:  BRA    10A0
010A0:  BRA    10A2
010A2:  NOP   
010A4:  BCF    F8B.4
010A6:  BCF    F94.4
010A8:  GOTO   10D4 (RETURN)
....................  
.................... #include <RS232_Lib.c>  
.................... //############################################################################## 
.................... //                    
.................... //    *********   ******* 
.................... //    *       *  *      * 
.................... //    *       *  *  
.................... //    *********   ******* 
.................... //    *   *              *   
.................... //    *    *      *      * 
.................... //    *      *     ****** 
.................... // 
....................  
....................  
.................... char getc1USART(); 
.................... void putc1USART(char c); 
.................... void puts1USART(char s); 
.................... char getc2USART(); 
.................... void putc2USART(char c); 
.................... void puts2USART(char s); 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   GET CHARACTER FROM USART1  
.................... char getc1USART() 
.................... { 
....................    #use rs232(baud = SPD_19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................    return(getc()); 
*
00B0E:  BTFSS  F9E.5
00B10:  BRA    0B0E
00B12:  MOVFF  FAE,01
.................... } 
00B16:  GOTO   0B1C (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   PUT CHARACTER TO USART1  
.................... void putc1USART(char c) 
.................... { 
....................    #use rs232(baud = SPD_19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................    putc(c); 
*
047D8:  MOVF   5E,W
047DA:  BTFSS  F9E.4
047DC:  BRA    47DA
047DE:  MOVWF  FAD
.................... } 
047E0:  GOTO   4920 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   PUT STRING TO USART1  
.................... void puts1USART(char s) 
.................... { 
....................    #use rs232(baud = SPD_19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................    puts(s); 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   GET CHARACTER FROM USART2  
.................... char getc2USART() 
.................... { 
....................    #use rs232(baud = SPD_38400, xmit = TX2, rcv = RX2, BITS = 8, PARITY = N) 
....................    return(getc()); 
*
00B7C:  BTFSS  FA4.5
00B7E:  BRA    0B7C
00B80:  MOVFF  F6E,01
.................... } 
00B84:  GOTO   0B8C (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   PUT CHARACTER TO USART2  
.................... void putc2USART(char c) 
.................... { 
....................   #use rs232(baud = SPD_38400, xmit = TX2, rcv = RX2, BITS = 8, PARITY = N) 
....................    putc(c); 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   PUT STRING TO USART1  
.................... void puts2USART(char s) 
.................... { 
....................    #use rs232(baud = SPD_38400, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................    puts(s); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //############################################################################\\ 
.................... //####################      Define Parameter       ###########################\\ 
....................        
....................    typedef struct 
....................       { 
....................          boolean Reset_Flag; 
....................          boolean Display_Spec;  
....................          boolean CompleteSpec; 
....................          boolean Get_Qr; 
....................          boolean Ack_Qr; 
....................          boolean ResCoils; 
....................          boolean ResScrew; 
....................          int Err_Coil; 
....................          byte ModeI; 
....................       }_Rob_; 
....................    _Rob_ Rob; 
....................     
....................    typedef struct 
....................       {          
....................          int16 C1h; 
....................          int16 C1l; 
....................          int16 C2h; 
....................          int16 C2l; 
....................          int16 C3h; 
....................          int16 C3l; 
....................          byte  BrSize; 
....................          byte  TypeScr; 
....................       } _Spec_; 
....................    _Spec_ SPEC; 
....................        
....................    byte sw; 
....................    char QR_Packet[20]; 
....................    char Qr_Show[20]; 
....................    //const char Vers[] = "V1.2.1"; 
....................    const int16 TimeOut = 2000; 
....................     
....................     
.................... byte GetStatus_SS(byte id)  ;   
....................     
.................... //-------------------------------------------------------:PCF8574 READ 
.................... byte GetStatus_SS(byte id)  
.................... { 
....................   byte idat;                       
....................       i2c_start();                       
*
010AC:  BSF    F94.4
010AE:  BRA    10B0
010B0:  BRA    10B2
010B2:  BSF    F94.3
010B4:  BRA    10B6
010B6:  BRA    10B8
010B8:  NOP   
010BA:  BCF    F8B.4
010BC:  BCF    F94.4
010BE:  BRA    10C0
010C0:  BRA    10C2
010C2:  BCF    F8B.3
010C4:  BCF    F94.3
....................       i2c_write(id+1); 
010C6:  MOVLW  01
010C8:  ADDWF  5E,W
010CA:  MOVWF  x60
010CC:  MOVWF  x61
010CE:  BRA    0FF4
....................       idat = i2c_read(0);              
010D0:  CLRF   00
010D2:  BRA    1052
010D4:  MOVFF  01,5F
....................       i2c_stop();                      
010D8:  BCF    F94.4
010DA:  NOP   
010DC:  BSF    F94.3
010DE:  BTFSS  F82.3
010E0:  BRA    10DE
010E2:  BRA    10E4
010E4:  BRA    10E6
010E6:  BRA    10E8
010E8:  NOP   
010EA:  BSF    F94.4
010EC:  BRA    10EE
010EE:  BRA    10F0
....................   return(idat); 
010F0:  MOVFF  5F,01
.................... } 
010F4:  RETLW  00
....................  
....................  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stamp_lib.c> 
....................  
.................... #define Operate_All_Process    0xFF 
.................... #define Check_Stamp            0xBF 
.................... #define Stamp_Only             0xAF 
....................  
.................... int16 cnt; 
....................  
.................... void _StatusIO_(void); 
.................... void StampOnly(void);  
.................... void Initial_SenSor(void);  
....................  
.................... void Trig_Counter(void); 
.................... void Buzzer_Alarm(byte tot); 
.................... void Buzzer_LongBeep(void); 
.................... void Start_Buzzer(void); 
.................... void Buzzer_Config(void); 
.................... void Buzzer_Beep(void); 
.................... void Display_CylinderError(void);  
.................... void Clear_Led(void);  
.................... void Diplay_Ready(void); 
.................... void Clear_LCD(void); 
.................... void _StatusIO_(void); 
....................  
.................... void OperateAll(void);  
.................... void Check_R_Stamp(void); 
.................... void ProcessMode(byte Mc); 
.................... void InsertData(float a, float b, float c); 
.................... void Initial_StageRobot(void); 
....................  
.................... void LED_RED(void); 
.................... void LED_GREEN(void); 
....................  
.................... boolean MOVE_GT(void); 
.................... boolean ORIGIN_GT(void); 
....................  
.................... boolean ORIGIN_STAMP(void); 
.................... boolean MOVE_STAMP(void); 
....................  
.................... boolean ORIGIN_PIN(void); 
.................... boolean MOVE_PIN(void); 
....................  
.................... boolean MOVE_BLOCK(void);  
.................... boolean ORIGIN_BLOCK(void); 
....................  
.................... boolean MOVE_QR(void); 
.................... boolean ORIGIN_QR(void); 
....................  
.................... boolean MOVE_LEFT(void); 
.................... boolean MOVE_RIGHT(void); 
....................  
.................... boolean MOVE_LEFT2(void); 
.................... boolean MOVE_RIGHT2(void); 
....................  
.................... boolean Resistance(void); 
.................... boolean Resistance3(void); 
.................... boolean JudgeMentCoil(int8 Jc); 
.................... boolean Check_Screw(boolean sc1,boolean sc2,boolean sc3); 
....................  
.................... //############################################################################## 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER STAMP MOVE 
.................... boolean MOVE_STAMP(void) 
.................... { 
....................    boolean ret; 
....................           if( !input(SS_STAMP_UP) ) 
*
02D52:  BTFSC  F81.5
02D54:  BRA    2D5A
....................                output_low(SV_STAMP); 
02D56:  BCF    F95.2
02D58:  BCF    F8C.2
....................                 
....................             for(cnt = 0; cnt < TimeOut; cnt++) 
02D5A:  CLRF   56
02D5C:  CLRF   55
02D5E:  MOVF   56,W
02D60:  SUBLW  07
02D62:  BNC   2D84
02D64:  BNZ   2D6C
02D66:  MOVF   55,W
02D68:  SUBLW  CF
02D6A:  BNC   2D84
....................                { 
....................                   if( !input(SS_STAMP_DOWN ) ) 
02D6C:  BTFSC  F81.4
02D6E:  BRA    2D74
....................                      { 
....................                         ret = TRUE; 
02D70:  BSF    5D.0
....................                         goto End_MOVE; 
02D72:  BRA    2D9A
....................                      } 
....................                   delay_ms(1);    
02D74:  MOVLW  01
02D76:  MOVWF  x9A
02D78:  CALL   0C22
....................                } 
02D7C:  INCF   55,F
02D7E:  BTFSC  FD8.2
02D80:  INCF   56,F
02D82:  BRA    2D5E
....................           
....................     ret = FALSE; 
02D84:  BCF    5D.0
....................     Display_CylinderError(); 
02D86:  CALL   15C0
....................     LED_RED(); 
02D8A:  CALL   1602
....................     Buzzer_Alarm(15); 
02D8E:  MOVLW  0F
02D90:  MOVWF  x8D
02D92:  CALL   1618
....................     output_high(SV_STAMP); 
02D96:  BCF    F95.2
02D98:  BSF    F8C.2
....................      
....................     End_MOVE :      
....................     return(ret); 
02D9A:  MOVLW  00
02D9C:  BTFSC  5D.0
02D9E:  MOVLW  01
02DA0:  MOVWF  01
.................... } 
02DA2:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER STAMP MOVE ORIGIN 
.................... boolean ORIGIN_STAMP(void) 
.................... { 
....................    boolean ret; 
....................     if(!input(SS_STAMP_DOWN)) 
02DA4:  BTFSC  F81.4
02DA6:  BRA    2DAC
....................          output_high(SV_STAMP); 
02DA8:  BCF    F95.2
02DAA:  BSF    F8C.2
....................           
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02DAC:  CLRF   56
02DAE:  CLRF   55
02DB0:  MOVF   56,W
02DB2:  SUBLW  07
02DB4:  BNC   2DD6
02DB6:  BNZ   2DBE
02DB8:  MOVF   55,W
02DBA:  SUBLW  CF
02DBC:  BNC   2DD6
....................          { 
....................             if(!input(SS_STAMP_UP)) 
02DBE:  BTFSC  F81.5
02DC0:  BRA    2DC6
....................                { 
....................                   ret = TRUE; 
02DC2:  BSF    5D.0
....................                   goto End_ORIGIN; 
02DC4:  BRA    2DEC
....................                } 
....................             delay_ms(1);    
02DC6:  MOVLW  01
02DC8:  MOVWF  x9A
02DCA:  CALL   0C22
....................          } 
02DCE:  INCF   55,F
02DD0:  BTFSC  FD8.2
02DD2:  INCF   56,F
02DD4:  BRA    2DB0
....................           
....................     ret = FALSE; 
02DD6:  BCF    5D.0
....................     Display_CylinderError(); 
02DD8:  CALL   15C0
....................     LED_RED(); 
02DDC:  CALL   1602
....................     Buzzer_Alarm(15); 
02DE0:  MOVLW  0F
02DE2:  MOVWF  x8D
02DE4:  CALL   1618
....................     output_low(SV_STAMP); 
02DE8:  BCF    F95.2
02DEA:  BCF    F8C.2
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02DEC:  MOVLW  00
02DEE:  BTFSC  5D.0
02DF0:  MOVLW  01
02DF2:  MOVWF  01
.................... } 
02DF4:  RETLW  00
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER PIN MOVE 
.................... boolean MOVE_PIN(void) 
.................... { 
....................    boolean ret; 
....................     
....................     if( !input(SS_COIL_UP)  ) 
*
016C0:  BTFSC  F86.0
016C2:  BRA    16C8
....................          output_low(SV_COILS); 
016C4:  BCF    F95.4
016C6:  BCF    F8C.4
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
016C8:  CLRF   56
016CA:  CLRF   55
016CC:  MOVF   56,W
016CE:  SUBLW  07
016D0:  BNC   16F2
016D2:  BNZ   16DA
016D4:  MOVF   55,W
016D6:  SUBLW  CF
016D8:  BNC   16F2
....................          { 
....................             if( !input(SS_COIL_DOWN) ) 
016DA:  BTFSC  F84.7
016DC:  BRA    16E2
....................                { 
....................                   ret = TRUE; 
016DE:  BSF    5D.0
....................                   goto End_MOVE; 
016E0:  BRA    1702
....................                } 
....................             delay_ms(1);    
016E2:  MOVLW  01
016E4:  MOVWF  x9A
016E6:  CALL   0C22
....................          } 
016EA:  INCF   55,F
016EC:  BTFSC  FD8.2
016EE:  INCF   56,F
016F0:  BRA    16CC
....................      
....................     ret = FALSE; 
016F2:  BCF    5D.0
....................     Display_CylinderError(); 
016F4:  RCALL  15C0
....................     LED_RED(); 
016F6:  RCALL  1602
....................     Buzzer_Alarm(15); 
016F8:  MOVLW  0F
016FA:  MOVWF  x8D
016FC:  RCALL  1618
....................     output_high(SV_COILS); 
016FE:  BCF    F95.4
01700:  BSF    F8C.4
....................      
....................     End_MOVE :      
....................     return(ret); 
01702:  MOVLW  00
01704:  BTFSC  5D.0
01706:  MOVLW  01
01708:  MOVWF  01
.................... } 
0170A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER PIN MOVE ORIGIN 
.................... boolean ORIGIN_PIN(void) 
.................... { 
....................    boolean ret; 
....................     if( (!input(SS_COIL_DOWN)) ) 
*
02C3C:  BTFSC  F84.7
02C3E:  BRA    2C44
....................          output_high(SV_COILS); 
02C40:  BCF    F95.4
02C42:  BSF    F8C.4
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02C44:  CLRF   56
02C46:  CLRF   55
02C48:  MOVF   56,W
02C4A:  SUBLW  07
02C4C:  BNC   2C6E
02C4E:  BNZ   2C56
02C50:  MOVF   55,W
02C52:  SUBLW  CF
02C54:  BNC   2C6E
....................          { 
....................             if( (!input(SS_COIL_UP)) ) 
02C56:  BTFSC  F86.0
02C58:  BRA    2C5E
....................                { 
....................                   ret = TRUE; 
02C5A:  BSF    5D.0
....................                   goto End_ORIGIN; 
02C5C:  BRA    2C84
....................                } 
....................             delay_ms(1);    
02C5E:  MOVLW  01
02C60:  MOVWF  x9A
02C62:  CALL   0C22
....................          } 
02C66:  INCF   55,F
02C68:  BTFSC  FD8.2
02C6A:  INCF   56,F
02C6C:  BRA    2C48
....................           
....................     ret = FALSE; 
02C6E:  BCF    5D.0
....................     Display_CylinderError(); 
02C70:  CALL   15C0
....................     LED_RED(); 
02C74:  CALL   1602
....................     Buzzer_Alarm(15); 
02C78:  MOVLW  0F
02C7A:  MOVWF  x8D
02C7C:  CALL   1618
....................     output_low(SV_COILS); 
02C80:  BCF    F95.4
02C82:  BCF    F8C.4
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02C84:  MOVLW  00
02C86:  BTFSC  5D.0
02C88:  MOVLW  01
02C8A:  MOVWF  01
.................... } 
02C8C:  RETLW  00
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER SCREW MOVE 
.................... boolean MOVE_GT(void)  
.................... { 
....................    boolean ret; 
....................     
....................     if( input(SS_SCREW_UP) ) 
*
0170C:  BTFSS  F86.3
0170E:  BRA    1714
....................          output_low(SV_SCREW); 
01710:  BCF    F95.5
01712:  BCF    F8C.5
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
01714:  CLRF   56
01716:  CLRF   55
01718:  MOVF   56,W
0171A:  SUBLW  07
0171C:  BNC   173E
0171E:  BNZ   1726
01720:  MOVF   55,W
01722:  SUBLW  CF
01724:  BNC   173E
....................          { 
....................             if( !input(SS_SCREW_UP) ) 
01726:  BTFSC  F86.3
01728:  BRA    172E
....................                { 
....................                   ret = TRUE; 
0172A:  BSF    5D.0
....................                   goto End_MOVE; 
0172C:  BRA    174E
....................                } 
....................             delay_ms(1);    
0172E:  MOVLW  01
01730:  MOVWF  x9A
01732:  CALL   0C22
....................          } 
01736:  INCF   55,F
01738:  BTFSC  FD8.2
0173A:  INCF   56,F
0173C:  BRA    1718
....................      
....................     ret = FALSE; 
0173E:  BCF    5D.0
....................     Display_CylinderError(); 
01740:  RCALL  15C0
....................     LED_RED(); 
01742:  RCALL  1602
....................     Buzzer_Alarm(15); 
01744:  MOVLW  0F
01746:  MOVWF  x8D
01748:  RCALL  1618
....................     output_high(SV_SCREW); 
0174A:  BCF    F95.5
0174C:  BSF    F8C.5
....................      
....................     End_MOVE :      
....................     return(ret); 
0174E:  MOVLW  00
01750:  BTFSC  5D.0
01752:  MOVLW  01
01754:  MOVWF  01
.................... } 
01756:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CYLINDER SCREW MOVE ORIGIN 
.................... boolean ORIGIN_GT(void) 
.................... { 
....................    boolean ret; 
....................     if( !input(SS_SCREW_UP) ) 
*
02C8E:  BTFSC  F86.3
02C90:  BRA    2C96
....................          output_high(SV_SCREW); 
02C92:  BCF    F95.5
02C94:  BSF    F8C.5
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02C96:  CLRF   56
02C98:  CLRF   55
02C9A:  MOVF   56,W
02C9C:  SUBLW  07
02C9E:  BNC   2CC0
02CA0:  BNZ   2CA8
02CA2:  MOVF   55,W
02CA4:  SUBLW  CF
02CA6:  BNC   2CC0
....................          { 
....................             if( input(SS_SCREW_UP) ) 
02CA8:  BTFSS  F86.3
02CAA:  BRA    2CB0
....................                { 
....................                   ret = TRUE; 
02CAC:  BSF    5D.0
....................                   goto End_ORIGIN; 
02CAE:  BRA    2CD6
....................                } 
....................             delay_ms(1);    
02CB0:  MOVLW  01
02CB2:  MOVWF  x9A
02CB4:  CALL   0C22
....................          } 
02CB8:  INCF   55,F
02CBA:  BTFSC  FD8.2
02CBC:  INCF   56,F
02CBE:  BRA    2C9A
....................           
....................     ret = FALSE; 
02CC0:  BCF    5D.0
....................     Display_CylinderError(); 
02CC2:  CALL   15C0
....................     LED_RED(); 
02CC6:  CALL   1602
....................     Buzzer_Alarm(15); 
02CCA:  MOVLW  0F
02CCC:  MOVWF  x8D
02CCE:  CALL   1618
....................     output_low(SV_SCREW); 
02CD2:  BCF    F95.5
02CD4:  BCF    F8C.5
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02CD6:  MOVLW  00
02CD8:  BTFSC  5D.0
02CDA:  MOVLW  01
02CDC:  MOVWF  01
.................... } 
02CDE:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE AXIS IN QR CODE 
.................... boolean MOVE_BLOCK(void)  
.................... { 
....................    boolean ret; 
....................     
....................     if( (!input(SS_UNLOCK)) ) 
*
02E9A:  BTFSC  F81.3
02E9C:  BRA    2EA2
....................          output_low(SV_LOCK); 
02E9E:  BCF    F95.1
02EA0:  BCF    F8C.1
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02EA2:  CLRF   56
02EA4:  CLRF   55
02EA6:  MOVF   56,W
02EA8:  SUBLW  07
02EAA:  BNC   2ECC
02EAC:  BNZ   2EB4
02EAE:  MOVF   55,W
02EB0:  SUBLW  CF
02EB2:  BNC   2ECC
....................          { 
....................             if( (!input(SS_LOCK)) ) 
02EB4:  BTFSC  F81.2
02EB6:  BRA    2EBC
....................                { 
....................                   ret = TRUE; 
02EB8:  BSF    5D.0
....................                   goto End_MOVE; 
02EBA:  BRA    2EE2
....................                } 
....................             delay_ms(1);    
02EBC:  MOVLW  01
02EBE:  MOVWF  x9A
02EC0:  CALL   0C22
....................          } 
02EC4:  INCF   55,F
02EC6:  BTFSC  FD8.2
02EC8:  INCF   56,F
02ECA:  BRA    2EA6
....................      
....................     ret = FALSE; 
02ECC:  BCF    5D.0
....................     Display_CylinderError(); 
02ECE:  CALL   15C0
....................     LED_RED(); 
02ED2:  CALL   1602
....................     Buzzer_Alarm(15); 
02ED6:  MOVLW  0F
02ED8:  MOVWF  x8D
02EDA:  CALL   1618
....................     output_high(SV_LOCK); 
02EDE:  BCF    F95.1
02EE0:  BSF    F8C.1
....................      
....................     End_MOVE :      
....................     return(ret); 
02EE2:  MOVLW  00
02EE4:  BTFSC  5D.0
02EE6:  MOVLW  01
02EE8:  MOVWF  01
.................... } 
02EEA:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE AXIS IN QR CODE TO ORIGIN 
.................... boolean ORIGIN_BLOCK(void) 
.................... { 
....................    boolean ret; 
....................     if( (!input(SS_LOCK)) ) 
02EEC:  BTFSC  F81.2
02EEE:  BRA    2EF4
....................          output_high(SV_LOCK); 
02EF0:  BCF    F95.1
02EF2:  BSF    F8C.1
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02EF4:  CLRF   56
02EF6:  CLRF   55
02EF8:  MOVF   56,W
02EFA:  SUBLW  07
02EFC:  BNC   2F1E
02EFE:  BNZ   2F06
02F00:  MOVF   55,W
02F02:  SUBLW  CF
02F04:  BNC   2F1E
....................          { 
....................             if( (!input(SS_UNLOCK)) ) 
02F06:  BTFSC  F81.3
02F08:  BRA    2F0E
....................                { 
....................                   ret = TRUE; 
02F0A:  BSF    5D.0
....................                   goto End_ORIGIN; 
02F0C:  BRA    2F34
....................                } 
....................             delay_ms(1);    
02F0E:  MOVLW  01
02F10:  MOVWF  x9A
02F12:  CALL   0C22
....................          } 
02F16:  INCF   55,F
02F18:  BTFSC  FD8.2
02F1A:  INCF   56,F
02F1C:  BRA    2EF8
....................           
....................     ret = FALSE; 
02F1E:  BCF    5D.0
....................     Display_CylinderError(); 
02F20:  CALL   15C0
....................     LED_RED(); 
02F24:  CALL   1602
....................     Buzzer_Alarm(15); 
02F28:  MOVLW  0F
02F2A:  MOVWF  x8D
02F2C:  CALL   1618
....................     output_low(SV_LOCK); 
02F30:  BCF    F95.1
02F32:  BCF    F8C.1
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02F34:  MOVLW  00
02F36:  BTFSC  5D.0
02F38:  MOVLW  01
02F3A:  MOVWF  01
.................... } 
02F3C:  RETLW  00
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE QR CODE FOR READ DATA 
.................... boolean MOVE_QR(void)  
.................... { 
....................    boolean ret; 
....................     
....................     if( !input(SS_QR_UP) ) 
*
02DF6:  BTFSC  F82.2
02DF8:  BRA    2DFE
....................          output_low(SV_QR); 
02DFA:  BCF    F95.3
02DFC:  BCF    F8C.3
....................     //else { output_high(LEDG); output_low(LEDR); delay_ms(500); } 
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02DFE:  CLRF   56
02E00:  CLRF   55
02E02:  MOVF   56,W
02E04:  SUBLW  07
02E06:  BNC   2E28
02E08:  BNZ   2E10
02E0A:  MOVF   55,W
02E0C:  SUBLW  CF
02E0E:  BNC   2E28
....................          { 
....................             if( !input(SS_QR_DOWN) ) 
02E10:  BTFSC  F82.1
02E12:  BRA    2E18
....................                { 
....................                   ret = TRUE; 
02E14:  BSF    5D.0
....................                   goto End_MOVE; 
02E16:  BRA    2E3E
....................                } 
....................             delay_ms(1);    
02E18:  MOVLW  01
02E1A:  MOVWF  x9A
02E1C:  CALL   0C22
....................          } 
02E20:  INCF   55,F
02E22:  BTFSC  FD8.2
02E24:  INCF   56,F
02E26:  BRA    2E02
....................      
....................     ret = FALSE; 
02E28:  BCF    5D.0
....................     Display_CylinderError(); 
02E2A:  CALL   15C0
....................     LED_RED(); 
02E2E:  CALL   1602
....................     Buzzer_Alarm(15); 
02E32:  MOVLW  0F
02E34:  MOVWF  x8D
02E36:  CALL   1618
....................     output_high(SV_QR); 
02E3A:  BCF    F95.3
02E3C:  BSF    F8C.3
....................      
....................     End_MOVE :      
....................     return(ret); 
02E3E:  MOVLW  00
02E40:  BTFSC  5D.0
02E42:  MOVLW  01
02E44:  MOVWF  01
.................... } 
02E46:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE QR CODE TO ORIGIN FOR READ DATA  
.................... boolean ORIGIN_QR(void) 
.................... { 
....................    boolean ret; 
....................     if( !input(SS_QR_DOWN) ) 
02E48:  BTFSC  F82.1
02E4A:  BRA    2E50
....................          output_high(SV_QR); 
02E4C:  BCF    F95.3
02E4E:  BSF    F8C.3
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02E50:  CLRF   56
02E52:  CLRF   55
02E54:  MOVF   56,W
02E56:  SUBLW  07
02E58:  BNC   2E7A
02E5A:  BNZ   2E62
02E5C:  MOVF   55,W
02E5E:  SUBLW  CF
02E60:  BNC   2E7A
....................          { 
....................             if( !input(SS_QR_UP) ) 
02E62:  BTFSC  F82.2
02E64:  BRA    2E6A
....................                { 
....................                   ret = TRUE; 
02E66:  BSF    5D.0
....................                   goto End_ORIGIN; 
02E68:  BRA    2E90
....................                } 
....................             delay_ms(1);    
02E6A:  MOVLW  01
02E6C:  MOVWF  x9A
02E6E:  CALL   0C22
....................          } 
02E72:  INCF   55,F
02E74:  BTFSC  FD8.2
02E76:  INCF   56,F
02E78:  BRA    2E54
....................           
....................     ret = FALSE; 
02E7A:  BCF    5D.0
....................     Display_CylinderError(); 
02E7C:  CALL   15C0
....................     LED_RED(); 
02E80:  CALL   1602
....................     Buzzer_Alarm(15); 
02E84:  MOVLW  0F
02E86:  MOVWF  x8D
02E88:  CALL   1618
....................     output_low(SV_QR); 
02E8C:  BCF    F95.3
02E8E:  BCF    F8C.3
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02E90:  MOVLW  00
02E92:  BTFSC  5D.0
02E94:  MOVLW  01
02E96:  MOVWF  01
.................... } 
02E98:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE INK TRAY FOR STAMP 
.................... boolean MOVE_RIGHT(void) 
.................... { 
....................    boolean ret; 
....................                    
....................     if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) 
....................            && (!input(SS_STAMP_UP)) && (!input(SS_L)) ) 
*
01654:  BTFSC  F86.0
01656:  BRA    166C
01658:  BTFSS  F86.3
0165A:  BRA    166C
0165C:  BTFSC  F82.2
0165E:  BRA    166C
01660:  BTFSC  F81.5
01662:  BRA    166C
01664:  BTFSC  F85.0
01666:  BRA    166C
....................                   output_low(SV_SLIDER); 
01668:  BCF    F95.0
0166A:  BCF    F8C.0
....................                
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
0166C:  CLRF   56
0166E:  CLRF   55
01670:  MOVF   56,W
01672:  SUBLW  07
01674:  BNC   16A6
01676:  BNZ   167E
01678:  MOVF   55,W
0167A:  SUBLW  CF
0167C:  BNC   16A6
....................          { 
....................             if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................                 (!input(SS_STAMP_UP)) && (!input(SS_R)) )  
0167E:  BTFSC  F86.0
01680:  BRA    1696
01682:  BTFSS  F86.3
01684:  BRA    1696
01686:  BTFSC  F82.2
01688:  BRA    1696
0168A:  BTFSC  F81.5
0168C:  BRA    1696
0168E:  BTFSC  F85.1
01690:  BRA    1696
....................                { 
....................                   ret = TRUE; 
01692:  BSF    5D.0
....................                   goto End_MOVE; 
01694:  BRA    16B6
....................                } 
....................             delay_ms(1);    
01696:  MOVLW  01
01698:  MOVWF  x9A
0169A:  CALL   0C22
....................          } 
0169E:  INCF   55,F
016A0:  BTFSC  FD8.2
016A2:  INCF   56,F
016A4:  BRA    1670
....................      
....................     ret = FALSE; 
016A6:  BCF    5D.0
....................     Display_CylinderError(); 
016A8:  RCALL  15C0
....................     LED_RED(); 
016AA:  RCALL  1602
....................     Buzzer_Alarm(15); 
016AC:  MOVLW  0F
016AE:  MOVWF  x8D
016B0:  RCALL  1618
....................     output_high(SV_SLIDER); 
016B2:  BCF    F95.0
016B4:  BSF    F8C.0
....................      
....................     End_MOVE :      
....................     return(ret); 
016B6:  MOVLW  00
016B8:  BTFSC  5D.0
016BA:  MOVLW  01
016BC:  MOVWF  01
.................... } 
016BE:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE INK TRAY TO ORIGIN  
.................... boolean MOVE_LEFT(void) 
.................... { 
....................    boolean ret; 
....................     if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................        (!input(SS_STAMP_UP)) && (!input(SS_R)) ) 
*
02CE0:  BTFSC  F86.0
02CE2:  BRA    2CF8
02CE4:  BTFSS  F86.3
02CE6:  BRA    2CF8
02CE8:  BTFSC  F82.2
02CEA:  BRA    2CF8
02CEC:  BTFSC  F81.5
02CEE:  BRA    2CF8
02CF0:  BTFSC  F85.1
02CF2:  BRA    2CF8
....................          output_high(SV_SLIDER); 
02CF4:  BCF    F95.0
02CF6:  BSF    F8C.0
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
02CF8:  CLRF   56
02CFA:  CLRF   55
02CFC:  MOVF   56,W
02CFE:  SUBLW  07
02D00:  BNC   2D32
02D02:  BNZ   2D0A
02D04:  MOVF   55,W
02D06:  SUBLW  CF
02D08:  BNC   2D32
....................          { 
....................             if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................               (!input(SS_STAMP_UP)) && (!input(SS_L)) ) 
02D0A:  BTFSC  F86.0
02D0C:  BRA    2D22
02D0E:  BTFSS  F86.3
02D10:  BRA    2D22
02D12:  BTFSC  F82.2
02D14:  BRA    2D22
02D16:  BTFSC  F81.5
02D18:  BRA    2D22
02D1A:  BTFSC  F85.0
02D1C:  BRA    2D22
....................                { 
....................                   ret = TRUE; 
02D1E:  BSF    5D.0
....................                   goto End_ORIGIN; 
02D20:  BRA    2D48
....................                } 
....................             delay_ms(1);    
02D22:  MOVLW  01
02D24:  MOVWF  x9A
02D26:  CALL   0C22
....................          } 
02D2A:  INCF   55,F
02D2C:  BTFSC  FD8.2
02D2E:  INCF   56,F
02D30:  BRA    2CFC
....................           
....................     ret = FALSE; 
02D32:  BCF    5D.0
....................     Display_CylinderError(); 
02D34:  CALL   15C0
....................     LED_RED(); 
02D38:  CALL   1602
....................     Buzzer_Alarm(15); 
02D3C:  MOVLW  0F
02D3E:  MOVWF  x8D
02D40:  CALL   1618
....................     output_low(SV_SLIDER); 
02D44:  BCF    F95.0
02D46:  BCF    F8C.0
....................      
....................     End_ORIGIN :      
....................     return(ret); 
02D48:  MOVLW  00
02D4A:  BTFSC  5D.0
02D4C:  MOVLW  01
02D4E:  MOVWF  01
.................... } 
02D50:  RETLW  00
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE INK TRAY FOR STAMP 
.................... boolean MOVE_RIGHT2(void) 
.................... { 
....................    boolean ret; 
....................                    
....................     if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) 
....................            && (!input(SS_STAMP_UP))  ) 
*
04452:  BTFSC  F86.0
04454:  BRA    4466
04456:  BTFSS  F86.3
04458:  BRA    4466
0445A:  BTFSC  F82.2
0445C:  BRA    4466
0445E:  BTFSC  F81.5
04460:  BRA    4466
....................                   output_low(SV_SLIDER); 
04462:  BCF    F95.0
04464:  BCF    F8C.0
....................                
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
04466:  CLRF   56
04468:  CLRF   55
0446A:  MOVF   56,W
0446C:  SUBLW  07
0446E:  BNC   449C
04470:  BNZ   4478
04472:  MOVF   55,W
04474:  SUBLW  CF
04476:  BNC   449C
....................          { 
....................             if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................                 (!input(SS_STAMP_UP)) )  
04478:  BTFSC  F86.0
0447A:  BRA    448C
0447C:  BTFSS  F86.3
0447E:  BRA    448C
04480:  BTFSC  F82.2
04482:  BRA    448C
04484:  BTFSC  F81.5
04486:  BRA    448C
....................                { 
....................                   ret = TRUE; 
04488:  BSF    5D.0
....................                   goto End_MOVE; 
0448A:  BRA    44B2
....................                } 
....................             delay_ms(1);    
0448C:  MOVLW  01
0448E:  MOVWF  x9A
04490:  CALL   0C22
....................          } 
04494:  INCF   55,F
04496:  BTFSC  FD8.2
04498:  INCF   56,F
0449A:  BRA    446A
....................      
....................     ret = FALSE; 
0449C:  BCF    5D.0
....................     Display_CylinderError(); 
0449E:  CALL   15C0
....................     LED_RED(); 
044A2:  CALL   1602
....................     Buzzer_Alarm(15); 
044A6:  MOVLW  0F
044A8:  MOVWF  x8D
044AA:  CALL   1618
....................     output_high(SV_SLIDER); 
044AE:  BCF    F95.0
044B0:  BSF    F8C.0
....................      
....................     End_MOVE :      
....................     return(ret); 
044B2:  MOVLW  00
044B4:  BTFSC  5D.0
044B6:  MOVLW  01
044B8:  MOVWF  01
.................... } 
044BA:  GOTO   4526 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   MOVE INK TRAY TO ORIGIN  
.................... boolean MOVE_LEFT2(void) 
.................... { 
....................    boolean ret; 
....................     if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................        (!input(SS_STAMP_UP)) ) 
*
043E6:  BTFSC  F86.0
043E8:  BRA    43FA
043EA:  BTFSS  F86.3
043EC:  BRA    43FA
043EE:  BTFSC  F82.2
043F0:  BRA    43FA
043F2:  BTFSC  F81.5
043F4:  BRA    43FA
....................          output_high(SV_SLIDER); 
043F6:  BCF    F95.0
043F8:  BSF    F8C.0
....................       for(cnt = 0; cnt < TimeOut; cnt++) 
043FA:  CLRF   56
043FC:  CLRF   55
043FE:  MOVF   56,W
04400:  SUBLW  07
04402:  BNC   4430
04404:  BNZ   440C
04406:  MOVF   55,W
04408:  SUBLW  CF
0440A:  BNC   4430
....................          { 
....................             if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................               (!input(SS_STAMP_UP)) ) 
0440C:  BTFSC  F86.0
0440E:  BRA    4420
04410:  BTFSS  F86.3
04412:  BRA    4420
04414:  BTFSC  F82.2
04416:  BRA    4420
04418:  BTFSC  F81.5
0441A:  BRA    4420
....................                { 
....................                   ret = TRUE; 
0441C:  BSF    5D.0
....................                   goto End_ORIGIN; 
0441E:  BRA    4446
....................                } 
....................             delay_ms(1);    
04420:  MOVLW  01
04422:  MOVWF  x9A
04424:  CALL   0C22
....................          } 
04428:  INCF   55,F
0442A:  BTFSC  FD8.2
0442C:  INCF   56,F
0442E:  BRA    43FE
....................           
....................     ret = FALSE; 
04430:  BCF    5D.0
....................     Display_CylinderError(); 
04432:  CALL   15C0
....................     LED_RED(); 
04436:  CALL   1602
....................     Buzzer_Alarm(15); 
0443A:  MOVLW  0F
0443C:  MOVWF  x8D
0443E:  CALL   1618
....................     output_low(SV_SLIDER); 
04442:  BCF    F95.0
04444:  BCF    F8C.0
....................      
....................     End_ORIGIN :      
....................     return(ret); 
04446:  MOVLW  00
04448:  BTFSC  5D.0
0444A:  MOVLW  01
0444C:  MOVWF  01
.................... } 
0444E:  GOTO   4500 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... //############################################################################## 
.................... //  
.................... //                  OPTION PART  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... //-------------------   
.................... void Clear_LCD(void) 
.................... { 
....................   lcd_gotoxy(1,1); printf(lcd_putc,"                   "); 
*
00EE4:  MOVLW  01
00EE6:  MOVWF  x9A
00EE8:  MOVWF  x9B
00EEA:  RCALL  0E36
00EEC:  CLRF   x8B
00EEE:  MOVF   x8B,W
00EF0:  CALL   00EC
00EF4:  INCF   x8B,F
00EF6:  MOVWF  00
00EF8:  MOVWF  x99
00EFA:  RCALL  0EA0
00EFC:  MOVLW  13
00EFE:  SUBWF  x8B,W
00F00:  BNZ   0EEE
....................   lcd_gotoxy(1,2); printf(lcd_putc,"                   "); 
00F02:  MOVLW  01
00F04:  MOVWF  x9A
00F06:  MOVLW  02
00F08:  MOVWF  x9B
00F0A:  RCALL  0E36
00F0C:  CLRF   x8B
00F0E:  MOVF   x8B,W
00F10:  CALL   00EC
00F14:  INCF   x8B,F
00F16:  MOVWF  00
00F18:  MOVWF  x99
00F1A:  RCALL  0EA0
00F1C:  MOVLW  13
00F1E:  SUBWF  x8B,W
00F20:  BNZ   0F0E
....................   lcd_gotoxy(1,3); printf(lcd_putc,"                   "); 
00F22:  MOVLW  01
00F24:  MOVWF  x9A
00F26:  MOVLW  03
00F28:  MOVWF  x9B
00F2A:  RCALL  0E36
00F2C:  CLRF   x8B
00F2E:  MOVF   x8B,W
00F30:  CALL   00EC
00F34:  INCF   x8B,F
00F36:  MOVWF  00
00F38:  MOVWF  x99
00F3A:  RCALL  0EA0
00F3C:  MOVLW  13
00F3E:  SUBWF  x8B,W
00F40:  BNZ   0F2E
....................   lcd_gotoxy(1,4); printf(lcd_putc,"                   "); 
00F42:  MOVLW  01
00F44:  MOVWF  x9A
00F46:  MOVLW  04
00F48:  MOVWF  x9B
00F4A:  RCALL  0E36
00F4C:  CLRF   x8B
00F4E:  MOVF   x8B,W
00F50:  CALL   00EC
00F54:  INCF   x8B,F
00F56:  MOVWF  00
00F58:  MOVWF  x99
00F5A:  RCALL  0EA0
00F5C:  MOVLW  13
00F5E:  SUBWF  x8B,W
00F60:  BNZ   0F4E
.................... } 
00F62:  RETLW  00
....................  
.................... //-------------------   
.................... void Trig_Counter(void) 
.................... { 
....................    output_low(TRIG);   delay_ms(250); 
*
044BE:  BCF    F8B.0
044C0:  MOVLW  FA
044C2:  MOVWF  x9A
044C4:  CALL   0C22
....................    output_high(TRIG);  delay_ms(10); 
044C8:  BSF    F8B.0
044CA:  MOVLW  0A
044CC:  MOVWF  x9A
044CE:  CALL   0C22
.................... } 
044D2:  GOTO   4568 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   BUZZER ALARM FOR RESET OR INITIAL MACHINE STATUS 
.................... void Start_Buzzer(void) 
.................... { 
....................    byte cnt; 
....................       for(cnt = 0; cnt < 2; cnt++) 
*
01500:  CLRF   5D
01502:  MOVF   5D,W
01504:  SUBLW  01
01506:  BNC   1520
....................          { 
....................             output_low(BUZZER);   delay_ms(120); 
01508:  BCF    F8D.1
0150A:  MOVLW  78
0150C:  MOVWF  x9A
0150E:  CALL   0C22
....................             output_high(BUZZER);  delay_ms(30); 
01512:  BSF    F8D.1
01514:  MOVLW  1E
01516:  MOVWF  x9A
01518:  CALL   0C22
....................          } 
0151C:  INCF   5D,F
0151E:  BRA    1502
.................... } 
01520:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------    
.................... void Buzzer_Config(void) 
.................... { 
....................    byte cnt; 
....................     
....................       for(cnt = 0; cnt < 2; cnt++) 
*
0321E:  CLRF   5E
03220:  MOVF   5E,W
03222:  SUBLW  01
03224:  BNC   323E
....................          { 
....................             output_low(BUZZER);   delay_ms(100); 
03226:  BCF    F8D.1
03228:  MOVLW  64
0322A:  MOVWF  x9A
0322C:  CALL   0C22
....................             output_high(BUZZER);  delay_ms(25); 
03230:  BSF    F8D.1
03232:  MOVLW  19
03234:  MOVWF  x9A
03236:  CALL   0C22
....................          } 
0323A:  INCF   5E,F
0323C:  BRA    3220
....................           
....................       output_low(BUZZER);   delay_ms(270); 
0323E:  BCF    F8D.1
03240:  MOVLW  02
03242:  MOVWF  5F
03244:  MOVLW  87
03246:  MOVWF  x9A
03248:  CALL   0C22
0324C:  DECFSZ 5F,F
0324E:  BRA    3244
....................       output_high(BUZZER);  delay_ms(80);   
03250:  BSF    F8D.1
03252:  MOVLW  50
03254:  MOVWF  x9A
03256:  CALL   0C22
....................        
....................       output_low(BUZZER);   delay_ms(100); 
0325A:  BCF    F8D.1
0325C:  MOVLW  64
0325E:  MOVWF  x9A
03260:  CALL   0C22
....................       output_high(BUZZER);  delay_ms(25); 
03264:  BSF    F8D.1
03266:  MOVLW  19
03268:  MOVWF  x9A
0326A:  CALL   0C22
.................... } 
0326E:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SHOW STATUS FROM CLICK THE BUTTON 
.................... void Buzzer_Beep(void) 
.................... { 
....................    output_low(BUZZER); delay_ms(100); 
*
03208:  BCF    F8D.1
0320A:  MOVLW  64
0320C:  MOVWF  x9A
0320E:  CALL   0C22
....................    output_high(BUZZER);  delay_ms(25); 
03212:  BSF    F8D.1
03214:  MOVLW  19
03216:  MOVWF  x9A
03218:  CALL   0C22
.................... } 
0321C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   ALARM FOR LONG VOLUME 
.................... void Buzzer_LongBeep(void) 
.................... { 
....................    output_low(BUZZER);   delay_ms(1000); 
*
031E8:  BCF    F8D.1
031EA:  MOVLW  04
031EC:  MOVWF  5D
031EE:  MOVLW  FA
031F0:  MOVWF  x9A
031F2:  CALL   0C22
031F6:  DECFSZ 5D,F
031F8:  BRA    31EE
....................    output_high(BUZZER);  delay_ms(125); 
031FA:  BSF    F8D.1
031FC:  MOVLW  7D
031FE:  MOVWF  x9A
03200:  CALL   0C22
.................... } 
03204:  GOTO   3FC6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   BUZZER ALARM  
.................... void Buzzer_Alarm(byte tot)  
.................... {     
....................     LED_RED(); 
*
01618:  RCALL  1602
....................     output_low(BUZZER);   delay_ms(1500); 
0161A:  BCF    F8D.1
0161C:  MOVLW  06
0161E:  MOVWF  x8E
01620:  MOVLW  FA
01622:  MOVWF  x9A
01624:  CALL   0C22
01628:  DECFSZ x8E,F
0162A:  BRA    1620
....................     output_high(BUZZER);  delay_ms(70); 
0162C:  BSF    F8D.1
0162E:  MOVLW  46
01630:  MOVWF  x9A
01632:  CALL   0C22
....................       for(; tot > 0 ; tot--) 
01636:  MOVF   x8D,F
01638:  BZ    1652
....................          { 
....................             output_low(BUZZER);   delay_ms(90); 
0163A:  BCF    F8D.1
0163C:  MOVLW  5A
0163E:  MOVWF  x9A
01640:  CALL   0C22
....................             output_high(BUZZER);  delay_ms(20); 
01644:  BSF    F8D.1
01646:  MOVLW  14
01648:  MOVWF  x9A
0164A:  CALL   0C22
....................          } 
0164E:  DECF   x8D,F
01650:  BRA    1636
.................... } 
01652:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   Display Error 
.................... void Display_CylinderError(void)  
.................... {     
....................     lcd_gotoxy(1,2); 
*
015C0:  MOVLW  01
015C2:  MOVWF  x9A
015C4:  MOVLW  02
015C6:  MOVWF  x9B
015C8:  RCALL  0E36
....................     printf(lcd_putc," Mistake...         "); 
015CA:  CLRF   5E
015CC:  MOVF   5E,W
015CE:  CALL   011E
015D2:  INCF   5E,F
015D4:  MOVWF  00
015D6:  MOVWF  x99
015D8:  RCALL  0EA0
015DA:  MOVLW  14
015DC:  SUBWF  5E,W
015DE:  BNZ   15CC
....................      
....................     lcd_gotoxy(1,3); 
015E0:  MOVLW  01
015E2:  MOVWF  x9A
015E4:  MOVLW  03
015E6:  MOVWF  x9B
015E8:  RCALL  0E36
....................     printf(lcd_putc," CYLINDER IS ERROR! "); 
015EA:  CLRF   5E
015EC:  MOVF   5E,W
015EE:  CALL   0152
015F2:  INCF   5E,F
015F4:  MOVWF  00
015F6:  MOVWF  x99
015F8:  RCALL  0EA0
015FA:  MOVLW  14
015FC:  SUBWF  5E,W
015FE:  BNZ   15EC
....................      
.................... } 
01600:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CLEAR JUDGEMENT STATUS OF OK AND NG 
.................... void Clear_Led(void)  
.................... { 
....................    output_high(LEDR);  
*
00E26:  BSF    F8D.3
....................    output_high(LEDG); 
00E28:  BSF    F8D.2
....................    output_high(RELAY);    
00E2A:  BSF    F89.3
....................    output_high(BUZZER); 
00E2C:  BSF    F8D.1
....................    delay_ms(10); 
00E2E:  MOVLW  0A
00E30:  MOVWF  x9A
00E32:  RCALL  0C22
.................... }   
00E34:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   DISPLAY STATUS FOR MACHINE IS READYING 
.................... void Diplay_Ready(void) 
.................... { 
....................    lcd_gotoxy(1,1); printf(lcd_putc,"   << MACHINE >>    "); 
*
01476:  MOVLW  01
01478:  MOVWF  x9A
0147A:  MOVWF  x9B
0147C:  RCALL  0E36
0147E:  CLRF   5D
01480:  MOVF   5D,W
01482:  CALL   0186
01486:  INCF   5D,F
01488:  MOVWF  00
0148A:  MOVWF  x99
0148C:  RCALL  0EA0
0148E:  MOVLW  14
01490:  SUBWF  5D,W
01492:  BNZ   1480
....................    lcd_gotoxy(1,2); printf(lcd_putc,"Ready...            "); 
01494:  MOVLW  01
01496:  MOVWF  x9A
01498:  MOVLW  02
0149A:  MOVWF  x9B
0149C:  RCALL  0E36
0149E:  CLRF   5D
014A0:  MOVF   5D,W
014A2:  CALL   01BA
014A6:  INCF   5D,F
014A8:  MOVWF  00
014AA:  MOVWF  x99
014AC:  RCALL  0EA0
014AE:  MOVLW  14
014B0:  SUBWF  5D,W
014B2:  BNZ   14A0
....................    lcd_gotoxy(1,3); printf(lcd_putc,"                    "); 
014B4:  MOVLW  01
014B6:  MOVWF  x9A
014B8:  MOVLW  03
014BA:  MOVWF  x9B
014BC:  RCALL  0E36
014BE:  CLRF   5D
014C0:  MOVF   5D,W
014C2:  CALL   01EE
014C6:  INCF   5D,F
014C8:  MOVWF  00
014CA:  MOVWF  x99
014CC:  RCALL  0EA0
014CE:  MOVLW  14
014D0:  SUBWF  5D,W
014D2:  BNZ   14C0
....................    lcd_gotoxy(1,4); printf(lcd_putc,"                    "); 
014D4:  MOVLW  01
014D6:  MOVWF  x9A
014D8:  MOVLW  04
014DA:  MOVWF  x9B
014DC:  RCALL  0E36
014DE:  CLRF   5D
014E0:  MOVF   5D,W
014E2:  CALL   01EE
014E6:  INCF   5D,F
014E8:  MOVWF  00
014EA:  MOVWF  x99
014EC:  RCALL  0EA0
014EE:  MOVLW  14
014F0:  SUBWF  5D,W
014F2:  BNZ   14E0
....................    delay_ms(50); 
014F4:  MOVLW  32
014F6:  MOVWF  x9A
014F8:  CALL   0C22
.................... } 
014FC:  GOTO   15BA (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   STATUS OK 
.................... void LED_GREEN(void) 
.................... { 
....................    output_low(LEDG);  delay_ms(100); 
*
043CE:  BCF    F8D.2
043D0:  MOVLW  64
043D2:  MOVWF  x9A
043D4:  CALL   0C22
....................    output_high(LEDR); delay_ms(100); 
043D8:  BSF    F8D.3
043DA:  MOVLW  64
043DC:  MOVWF  x9A
043DE:  CALL   0C22
.................... } 
043E2:  GOTO   45CA (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   STATUS NG 
.................... void LED_RED(void) 
.................... {    
....................    output_low(LEDR);  delay_ms(100); 
*
01602:  BCF    F8D.3
01604:  MOVLW  64
01606:  MOVWF  x9A
01608:  CALL   0C22
....................    output_high(LEDG); delay_ms(100); 
0160C:  BSF    F8D.2
0160E:  MOVLW  64
01610:  MOVWF  x9A
01612:  CALL   0C22
.................... } 
01616:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   Judgement Coil 
.................... boolean AdjudgeCoils(int8 Jc) 
.................... { 
....................    boolean ret = FALSE; 
*
01F8C:  BCF    x8C.0
....................    switch(Jc) 
....................       { 
01F8E:  MOVF   x8B,W
01F90:  ADDLW  F8
01F92:  BTFSC  FD8.0
01F94:  BRA    21A2
01F96:  ADDLW  08
01F98:  GOTO   21AC
....................          case 0:  ret = TRUE; 
01F9C:  BSF    x8C.0
....................          break; 
01F9E:  BRA    21A2
....................           
....................          case 1: 
....................                   delay_ms(150); 
01FA0:  MOVLW  96
01FA2:  MOVWF  x9A
01FA4:  CALL   0C22
....................                   ret = FALSE; 
01FA8:  BCF    x8C.0
....................                   LED_RED(); 
01FAA:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil%u is NG         ",Jc);                   
01FAE:  MOVLW  01
01FB0:  MOVWF  x9A
01FB2:  MOVWF  x9B
01FB4:  CALL   0E36
01FB8:  CLRF   x8D
01FBA:  MOVF   x8D,W
01FBC:  CALL   0222
01FC0:  INCF   x8D,F
01FC2:  MOVWF  00
01FC4:  MOVWF  x99
01FC6:  CALL   0EA0
01FCA:  MOVLW  04
01FCC:  SUBWF  x8D,W
01FCE:  BNZ   1FBA
01FD0:  MOVFF  8B,8E
01FD4:  MOVLW  1B
01FD6:  MOVWF  x8F
01FD8:  RCALL  1F20
01FDA:  MOVLW  06
01FDC:  MOVWF  x8E
01FDE:  MOVF   x8E,W
01FE0:  CALL   0222
01FE4:  INCF   x8E,F
01FE6:  MOVWF  00
01FE8:  MOVWF  x99
01FEA:  CALL   0EA0
01FEE:  MOVLW  15
01FF0:  SUBWF  x8E,W
01FF2:  BNZ   1FDE
....................                   Buzzer_Alarm(15); 
01FF4:  MOVLW  0F
01FF6:  MOVWF  x8D
01FF8:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780); 
....................          break; 
01FFC:  BRA    21A2
....................           
....................          case 2: 
....................                   delay_ms(150); 
01FFE:  MOVLW  96
02000:  MOVWF  x9A
02002:  CALL   0C22
....................                   ret = FALSE; 
02006:  BCF    x8C.0
....................                   LED_RED(); 
02008:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil%u is NG         ",Jc);                   
0200C:  MOVLW  01
0200E:  MOVWF  x9A
02010:  MOVWF  x9B
02012:  CALL   0E36
02016:  CLRF   x8D
02018:  MOVF   x8D,W
0201A:  CALL   0222
0201E:  INCF   x8D,F
02020:  MOVWF  00
02022:  MOVWF  x99
02024:  CALL   0EA0
02028:  MOVLW  04
0202A:  SUBWF  x8D,W
0202C:  BNZ   2018
0202E:  MOVFF  8B,8E
02032:  MOVLW  1B
02034:  MOVWF  x8F
02036:  RCALL  1F20
02038:  MOVLW  06
0203A:  MOVWF  x8E
0203C:  MOVF   x8E,W
0203E:  CALL   0222
02042:  INCF   x8E,F
02044:  MOVWF  00
02046:  MOVWF  x99
02048:  CALL   0EA0
0204C:  MOVLW  15
0204E:  SUBWF  x8E,W
02050:  BNZ   203C
....................                   Buzzer_Alarm(15); 
02052:  MOVLW  0F
02054:  MOVWF  x8D
02056:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780);  
....................          break; 
0205A:  BRA    21A2
....................           
....................          case 3: 
....................                   delay_ms(150); 
0205C:  MOVLW  96
0205E:  MOVWF  x9A
02060:  CALL   0C22
....................                   ret = FALSE; 
02064:  BCF    x8C.0
....................                   LED_RED(); 
02066:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil%u is NG         ",Jc);                   
0206A:  MOVLW  01
0206C:  MOVWF  x9A
0206E:  MOVWF  x9B
02070:  CALL   0E36
02074:  CLRF   x8D
02076:  MOVF   x8D,W
02078:  CALL   0222
0207C:  INCF   x8D,F
0207E:  MOVWF  00
02080:  MOVWF  x99
02082:  CALL   0EA0
02086:  MOVLW  04
02088:  SUBWF  x8D,W
0208A:  BNZ   2076
0208C:  MOVFF  8B,8E
02090:  MOVLW  1B
02092:  MOVWF  x8F
02094:  RCALL  1F20
02096:  MOVLW  06
02098:  MOVWF  x8E
0209A:  MOVF   x8E,W
0209C:  CALL   0222
020A0:  INCF   x8E,F
020A2:  MOVWF  00
020A4:  MOVWF  x99
020A6:  CALL   0EA0
020AA:  MOVLW  15
020AC:  SUBWF  x8E,W
020AE:  BNZ   209A
....................                   Buzzer_Alarm(15); 
020B0:  MOVLW  0F
020B2:  MOVWF  x8D
020B4:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780);  
....................          break; 
020B8:  BRA    21A2
....................           
....................          case 4: 
....................                   delay_ms(150); 
020BA:  MOVLW  96
020BC:  MOVWF  x9A
020BE:  CALL   0C22
....................                   ret = FALSE; 
020C2:  BCF    x8C.0
....................                   LED_RED(); 
020C4:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil1-2 is NG         ");                   
020C8:  MOVLW  01
020CA:  MOVWF  x9A
020CC:  MOVWF  x9B
020CE:  CALL   0E36
020D2:  CLRF   x8D
020D4:  MOVF   x8D,W
020D6:  CALL   0256
020DA:  INCF   x8D,F
020DC:  MOVWF  00
020DE:  MOVWF  x99
020E0:  CALL   0EA0
020E4:  MOVLW  16
020E6:  SUBWF  x8D,W
020E8:  BNZ   20D4
....................                   Buzzer_Alarm(15); 
020EA:  MOVLW  0F
020EC:  MOVWF  x8D
020EE:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780);  
....................          break; 
020F2:  BRA    21A2
....................           
....................         case 5: 
....................                   delay_ms(150); 
020F4:  MOVLW  96
020F6:  MOVWF  x9A
020F8:  CALL   0C22
....................                   ret = FALSE; 
020FC:  BCF    x8C.0
....................                   LED_RED(); 
020FE:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil1-3 is NG         ");                   
02102:  MOVLW  01
02104:  MOVWF  x9A
02106:  MOVWF  x9B
02108:  CALL   0E36
0210C:  CLRF   x8D
0210E:  MOVF   x8D,W
02110:  CALL   028C
02114:  INCF   x8D,F
02116:  MOVWF  00
02118:  MOVWF  x99
0211A:  CALL   0EA0
0211E:  MOVLW  16
02120:  SUBWF  x8D,W
02122:  BNZ   210E
....................                   Buzzer_Alarm(15); 
02124:  MOVLW  0F
02126:  MOVWF  x8D
02128:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780);  
....................          break; 
0212C:  BRA    21A2
....................           
....................          case 6: 
....................                   delay_ms(150); 
0212E:  MOVLW  96
02130:  MOVWF  x9A
02132:  CALL   0C22
....................                   ret = FALSE; 
02136:  BCF    x8C.0
....................                   LED_RED(); 
02138:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil2-3 is NG         ");                   
0213C:  MOVLW  01
0213E:  MOVWF  x9A
02140:  MOVWF  x9B
02142:  CALL   0E36
02146:  CLRF   x8D
02148:  MOVF   x8D,W
0214A:  CALL   02C2
0214E:  INCF   x8D,F
02150:  MOVWF  00
02152:  MOVWF  x99
02154:  CALL   0EA0
02158:  MOVLW  16
0215A:  SUBWF  x8D,W
0215C:  BNZ   2148
....................                   Buzzer_Alarm(15); 
0215E:  MOVLW  0F
02160:  MOVWF  x8D
02162:  CALL   1618
....................                   //output_low(SV_SLIDER);  delay_ms(780);  
....................          break; 
02166:  BRA    21A2
....................           
....................           
....................           
....................          case 7: 
....................                   delay_ms(150); 
02168:  MOVLW  96
0216A:  MOVWF  x9A
0216C:  CALL   0C22
....................                   ret = FALSE; 
02170:  BCF    x8C.0
....................                   LED_RED(); 
02172:  CALL   1602
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"Coil 1-3 is NG       ");                   
02176:  MOVLW  01
02178:  MOVWF  x9A
0217A:  MOVWF  x9B
0217C:  CALL   0E36
02180:  CLRF   x8D
02182:  MOVF   x8D,W
02184:  CALL   02F8
02188:  INCF   x8D,F
0218A:  MOVWF  00
0218C:  MOVWF  x99
0218E:  CALL   0EA0
02192:  MOVLW  15
02194:  SUBWF  x8D,W
02196:  BNZ   2182
....................                   Buzzer_Alarm(15); 
02198:  MOVLW  0F
0219A:  MOVWF  x8D
0219C:  CALL   1618
....................                   //output_low(SV_SLIDER); 
....................          break; 
021A0:  BRA    21A2
....................       } 
....................        
....................     return(ret); 
021A2:  MOVLW  00
021A4:  BTFSC  x8C.0
021A6:  MOVLW  01
021A8:  MOVWF  01
.................... } 
021AA:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
.................... //                                                   =- 
.................... //                Check Coils Resistance             -= 
.................... //                                                   =- 
.................... //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- 
.................... boolean Resistance3(void) 
.................... { 
.................... //float Vbe = 0.00488; 
....................    float Value1 ; 
....................    float Value2; 
....................    float Value3 ; 
....................    float V1 ; 
....................    float V2 ; 
....................    float V3 ; 
....................    float R1 ; 
....................    float R2 ; 
....................    float R3 ; 
....................    float Im ; 
....................    float Im3; 
....................    boolean r1_flag,r2_flag,r3_flag; 
....................    boolean Judge = FALSE; 
*
023F0:  BCF    x89.3
....................    byte   I ; 
....................     
....................       Clear_LCD(); 
023F2:  CALL   0EE4
....................       output_high(RELAY) ; 
023F6:  BSF    F89.3
....................       delay_ms(500) ; 
023F8:  MOVLW  02
023FA:  MOVWF  x8B
023FC:  MOVLW  FA
023FE:  MOVWF  x9A
02400:  CALL   0C22
02404:  DECFSZ x8B,F
02406:  BRA    23FC
....................        
.................... //****************************************************************************** 
.................... // Coil Judgement -> Judge = 0 All Coils is OK 
.................... //                   Judge = 1 First Coil is NG 
.................... //                   Judge = 2 Second Coil is NG 
.................... //                   Judge = 3 All Coil is NG 
.................... //****************************************************************************** 
....................      
....................       /// CHECK THE FIRST COIL AND SECOND COIL   
....................       r1_flag = FALSE; 
02408:  BCF    x89.0
....................       r2_flag = FALSE; 
0240A:  BCF    x89.1
....................       r3_flag = FALSE; 
0240C:  BCF    x89.2
....................       Value1 = 0 ; 
0240E:  CLRF   x60
02410:  CLRF   5F
02412:  CLRF   5E
02414:  CLRF   5D
....................       Value2 = 0 ; 
02416:  CLRF   x64
02418:  CLRF   x63
0241A:  CLRF   x62
0241C:  CLRF   x61
....................       Value3 = 0 ; 
0241E:  CLRF   x68
02420:  CLRF   x67
02422:  CLRF   x66
02424:  CLRF   x65
....................       V1 = 0 ; 
02426:  CLRF   x6C
02428:  CLRF   x6B
0242A:  CLRF   x6A
0242C:  CLRF   x69
....................       V2 = 0 ; 
0242E:  CLRF   x70
02430:  CLRF   x6F
02432:  CLRF   x6E
02434:  CLRF   x6D
....................       V3 = 0 ; 
02436:  CLRF   x74
02438:  CLRF   x73
0243A:  CLRF   x72
0243C:  CLRF   x71
....................       R1 = 0;  
0243E:  CLRF   x78
02440:  CLRF   x77
02442:  CLRF   x76
02444:  CLRF   x75
....................       R2 = 0;  
02446:  CLRF   x7C
02448:  CLRF   x7B
0244A:  CLRF   x7A
0244C:  CLRF   x79
....................       R3 = 0; 
0244E:  CLRF   x80
02450:  CLRF   x7F
02452:  CLRF   x7E
02454:  CLRF   x7D
....................       for(I = 0 ;I < 20 ;I++)  
02456:  CLRF   x8A
02458:  MOVF   x8A,W
0245A:  SUBLW  13
0245C:  BTFSS  FD8.0
0245E:  BRA    263E
....................          { 
....................             set_adc_channel(0); 
02460:  MOVLW  00
02462:  MOVWF  01
02464:  MOVF   FC2,W
02466:  ANDLW  C3
02468:  IORWF  01,W
0246A:  MOVWF  FC2
....................             delay_us(20); 
0246C:  MOVLW  42
0246E:  MOVWF  00
02470:  DECFSZ 00,F
02472:  BRA    2470
02474:  NOP   
....................             Value1 = read_adc(); 
02476:  BSF    FC2.1
02478:  BTFSC  FC2.1
0247A:  BRA    2478
0247C:  MOVFF  FC4,03
02480:  MOVFF  FC3,8B
02484:  MOVFF  FC4,8C
02488:  CALL   1758
0248C:  MOVFF  03,60
02490:  MOVFF  02,5F
02494:  MOVFF  01,5E
02498:  MOVFF  00,5D
....................             V1 = V1+(Value1*(5.01/1024)); 
0249C:  MOVFF  60,A7
024A0:  MOVFF  5F,A6
024A4:  MOVFF  5E,A5
024A8:  MOVFF  5D,A4
024AC:  MOVLW  EC
024AE:  MOVWF  xAB
024B0:  MOVLW  51
024B2:  MOVWF  xAA
024B4:  MOVLW  20
024B6:  MOVWF  xA9
024B8:  MOVLW  77
024BA:  MOVWF  xA8
024BC:  CALL   178E
024C0:  BCF    FD8.1
024C2:  MOVFF  6C,92
024C6:  MOVFF  6B,91
024CA:  MOVFF  6A,90
024CE:  MOVFF  69,8F
024D2:  MOVFF  03,96
024D6:  MOVFF  02,95
024DA:  MOVFF  01,94
024DE:  MOVFF  00,93
024E2:  CALL   1880
024E6:  MOVFF  03,6C
024EA:  MOVFF  02,6B
024EE:  MOVFF  01,6A
024F2:  MOVFF  00,69
....................             delay_ms(5); 
024F6:  MOVLW  05
024F8:  MOVWF  x9A
024FA:  CALL   0C22
....................              
....................             set_adc_channel(1); 
024FE:  MOVLW  04
02500:  MOVWF  01
02502:  MOVF   FC2,W
02504:  ANDLW  C3
02506:  IORWF  01,W
02508:  MOVWF  FC2
....................             delay_us(20); 
0250A:  MOVLW  42
0250C:  MOVWF  00
0250E:  DECFSZ 00,F
02510:  BRA    250E
02512:  NOP   
....................             Value2 = read_adc(); 
02514:  BSF    FC2.1
02516:  BTFSC  FC2.1
02518:  BRA    2516
0251A:  MOVFF  FC4,03
0251E:  MOVFF  FC3,8B
02522:  MOVFF  FC4,8C
02526:  CALL   1758
0252A:  MOVFF  03,64
0252E:  MOVFF  02,63
02532:  MOVFF  01,62
02536:  MOVFF  00,61
....................             V2 = V2+(Value2*(5.01/1024)); 
0253A:  MOVFF  64,A7
0253E:  MOVFF  63,A6
02542:  MOVFF  62,A5
02546:  MOVFF  61,A4
0254A:  MOVLW  EC
0254C:  MOVWF  xAB
0254E:  MOVLW  51
02550:  MOVWF  xAA
02552:  MOVLW  20
02554:  MOVWF  xA9
02556:  MOVLW  77
02558:  MOVWF  xA8
0255A:  CALL   178E
0255E:  BCF    FD8.1
02560:  MOVFF  70,92
02564:  MOVFF  6F,91
02568:  MOVFF  6E,90
0256C:  MOVFF  6D,8F
02570:  MOVFF  03,96
02574:  MOVFF  02,95
02578:  MOVFF  01,94
0257C:  MOVFF  00,93
02580:  CALL   1880
02584:  MOVFF  03,70
02588:  MOVFF  02,6F
0258C:  MOVFF  01,6E
02590:  MOVFF  00,6D
....................             delay_ms(5); 
02594:  MOVLW  05
02596:  MOVWF  x9A
02598:  CALL   0C22
....................              
....................             set_adc_channel(2); 
0259C:  MOVLW  08
0259E:  MOVWF  01
025A0:  MOVF   FC2,W
025A2:  ANDLW  C3
025A4:  IORWF  01,W
025A6:  MOVWF  FC2
....................             delay_us(20); 
025A8:  MOVLW  42
025AA:  MOVWF  00
025AC:  DECFSZ 00,F
025AE:  BRA    25AC
025B0:  NOP   
....................             Value3 = read_adc(); 
025B2:  BSF    FC2.1
025B4:  BTFSC  FC2.1
025B6:  BRA    25B4
025B8:  MOVFF  FC4,03
025BC:  MOVFF  FC3,8B
025C0:  MOVFF  FC4,8C
025C4:  CALL   1758
025C8:  MOVFF  03,68
025CC:  MOVFF  02,67
025D0:  MOVFF  01,66
025D4:  MOVFF  00,65
....................             V3 = V3+(Value3*(5.01/1024)); 
025D8:  MOVFF  68,A7
025DC:  MOVFF  67,A6
025E0:  MOVFF  66,A5
025E4:  MOVFF  65,A4
025E8:  MOVLW  EC
025EA:  MOVWF  xAB
025EC:  MOVLW  51
025EE:  MOVWF  xAA
025F0:  MOVLW  20
025F2:  MOVWF  xA9
025F4:  MOVLW  77
025F6:  MOVWF  xA8
025F8:  CALL   178E
025FC:  BCF    FD8.1
025FE:  MOVFF  74,92
02602:  MOVFF  73,91
02606:  MOVFF  72,90
0260A:  MOVFF  71,8F
0260E:  MOVFF  03,96
02612:  MOVFF  02,95
02616:  MOVFF  01,94
0261A:  MOVFF  00,93
0261E:  CALL   1880
02622:  MOVFF  03,74
02626:  MOVFF  02,73
0262A:  MOVFF  01,72
0262E:  MOVFF  00,71
....................             delay_ms(5); 
02632:  MOVLW  05
02634:  MOVWF  x9A
02636:  CALL   0C22
....................          } 
0263A:  INCF   x8A,F
0263C:  BRA    2458
....................       
....................       V1 = (V1/20); 
0263E:  MOVFF  6C,92
02642:  MOVFF  6B,91
02646:  MOVFF  6A,90
0264A:  MOVFF  69,8F
0264E:  CLRF   x96
02650:  CLRF   x95
02652:  MOVLW  20
02654:  MOVWF  x94
02656:  MOVLW  83
02658:  MOVWF  x93
0265A:  CALL   1AEA
0265E:  MOVFF  03,6C
02662:  MOVFF  02,6B
02666:  MOVFF  01,6A
0266A:  MOVFF  00,69
....................       Im = (5 - V1)/100; 
0266E:  BSF    FD8.1
02670:  CLRF   x92
02672:  CLRF   x91
02674:  MOVLW  20
02676:  MOVWF  x90
02678:  MOVLW  81
0267A:  MOVWF  x8F
0267C:  MOVFF  6C,96
02680:  MOVFF  6B,95
02684:  MOVFF  6A,94
02688:  MOVFF  69,93
0268C:  CALL   1880
02690:  MOVFF  00,8B
02694:  MOVFF  01,8C
02698:  MOVFF  02,8D
0269C:  MOVFF  03,8E
026A0:  MOVFF  03,92
026A4:  MOVFF  02,91
026A8:  MOVFF  01,90
026AC:  MOVFF  00,8F
026B0:  CLRF   x96
026B2:  CLRF   x95
026B4:  MOVLW  48
026B6:  MOVWF  x94
026B8:  MOVLW  85
026BA:  MOVWF  x93
026BC:  CALL   1AEA
026C0:  MOVFF  03,84
026C4:  MOVFF  02,83
026C8:  MOVFF  01,82
026CC:  MOVFF  00,81
....................       R1 = V1/Im; 
026D0:  MOVFF  6C,92
026D4:  MOVFF  6B,91
026D8:  MOVFF  6A,90
026DC:  MOVFF  69,8F
026E0:  MOVFF  84,96
026E4:  MOVFF  83,95
026E8:  MOVFF  82,94
026EC:  MOVFF  81,93
026F0:  CALL   1AEA
026F4:  MOVFF  03,78
026F8:  MOVFF  02,77
026FC:  MOVFF  01,76
02700:  MOVFF  00,75
....................        
....................       V2 = (V2/20); 
02704:  MOVFF  70,92
02708:  MOVFF  6F,91
0270C:  MOVFF  6E,90
02710:  MOVFF  6D,8F
02714:  CLRF   x96
02716:  CLRF   x95
02718:  MOVLW  20
0271A:  MOVWF  x94
0271C:  MOVLW  83
0271E:  MOVWF  x93
02720:  CALL   1AEA
02724:  MOVFF  03,70
02728:  MOVFF  02,6F
0272C:  MOVFF  01,6E
02730:  MOVFF  00,6D
....................       Im = (5 - V2)/100; 
02734:  BSF    FD8.1
02736:  CLRF   x92
02738:  CLRF   x91
0273A:  MOVLW  20
0273C:  MOVWF  x90
0273E:  MOVLW  81
02740:  MOVWF  x8F
02742:  MOVFF  70,96
02746:  MOVFF  6F,95
0274A:  MOVFF  6E,94
0274E:  MOVFF  6D,93
02752:  CALL   1880
02756:  MOVFF  00,8B
0275A:  MOVFF  01,8C
0275E:  MOVFF  02,8D
02762:  MOVFF  03,8E
02766:  MOVFF  03,92
0276A:  MOVFF  02,91
0276E:  MOVFF  01,90
02772:  MOVFF  00,8F
02776:  CLRF   x96
02778:  CLRF   x95
0277A:  MOVLW  48
0277C:  MOVWF  x94
0277E:  MOVLW  85
02780:  MOVWF  x93
02782:  CALL   1AEA
02786:  MOVFF  03,84
0278A:  MOVFF  02,83
0278E:  MOVFF  01,82
02792:  MOVFF  00,81
....................       R2 = V2/Im;    
02796:  MOVFF  70,92
0279A:  MOVFF  6F,91
0279E:  MOVFF  6E,90
027A2:  MOVFF  6D,8F
027A6:  MOVFF  84,96
027AA:  MOVFF  83,95
027AE:  MOVFF  82,94
027B2:  MOVFF  81,93
027B6:  CALL   1AEA
027BA:  MOVFF  03,7C
027BE:  MOVFF  02,7B
027C2:  MOVFF  01,7A
027C6:  MOVFF  00,79
....................        
....................       V3 = (V3/20); 
027CA:  MOVFF  74,92
027CE:  MOVFF  73,91
027D2:  MOVFF  72,90
027D6:  MOVFF  71,8F
027DA:  CLRF   x96
027DC:  CLRF   x95
027DE:  MOVLW  20
027E0:  MOVWF  x94
027E2:  MOVLW  83
027E4:  MOVWF  x93
027E6:  CALL   1AEA
027EA:  MOVFF  03,74
027EE:  MOVFF  02,73
027F2:  MOVFF  01,72
027F6:  MOVFF  00,71
....................       Im3 = (5 - V3)/100; 
027FA:  BSF    FD8.1
027FC:  CLRF   x92
027FE:  CLRF   x91
02800:  MOVLW  20
02802:  MOVWF  x90
02804:  MOVLW  81
02806:  MOVWF  x8F
02808:  MOVFF  74,96
0280C:  MOVFF  73,95
02810:  MOVFF  72,94
02814:  MOVFF  71,93
02818:  CALL   1880
0281C:  MOVFF  00,8B
02820:  MOVFF  01,8C
02824:  MOVFF  02,8D
02828:  MOVFF  03,8E
0282C:  MOVFF  03,92
02830:  MOVFF  02,91
02834:  MOVFF  01,90
02838:  MOVFF  00,8F
0283C:  CLRF   x96
0283E:  CLRF   x95
02840:  MOVLW  48
02842:  MOVWF  x94
02844:  MOVLW  85
02846:  MOVWF  x93
02848:  CALL   1AEA
0284C:  MOVFF  03,88
02850:  MOVFF  02,87
02854:  MOVFF  01,86
02858:  MOVFF  00,85
....................       R3 = (V3/Im3)-2;  
0285C:  MOVFF  74,92
02860:  MOVFF  73,91
02864:  MOVFF  72,90
02868:  MOVFF  71,8F
0286C:  MOVFF  88,96
02870:  MOVFF  87,95
02874:  MOVFF  86,94
02878:  MOVFF  85,93
0287C:  CALL   1AEA
02880:  MOVFF  00,8B
02884:  MOVFF  01,8C
02888:  MOVFF  02,8D
0288C:  MOVFF  03,8E
02890:  BSF    FD8.1
02892:  MOVFF  03,92
02896:  MOVFF  02,91
0289A:  MOVFF  01,90
0289E:  MOVFF  00,8F
028A2:  CLRF   x96
028A4:  CLRF   x95
028A6:  CLRF   x94
028A8:  MOVLW  80
028AA:  MOVWF  x93
028AC:  CALL   1880
028B0:  MOVFF  03,80
028B4:  MOVFF  02,7F
028B8:  MOVFF  01,7E
028BC:  MOVFF  00,7D
....................        
....................        
....................        
....................       delay_ms(100); 
028C0:  MOVLW  64
028C2:  MOVWF  x9A
028C4:  CALL   0C22
....................       lcd_gotoxy(1,2); printf(lcd_putc," C1 = %f",R1); 
028C8:  MOVLW  01
028CA:  MOVWF  x9A
028CC:  MOVLW  02
028CE:  MOVWF  x9B
028D0:  CALL   0E36
028D4:  CLRF   x8B
028D6:  MOVF   x8B,W
028D8:  CALL   032C
028DC:  INCF   x8B,F
028DE:  MOVWF  00
028E0:  MOVWF  x99
028E2:  CALL   0EA0
028E6:  MOVLW  06
028E8:  SUBWF  x8B,W
028EA:  BNZ   28D6
028EC:  MOVLW  89
028EE:  MOVWF  FE9
028F0:  MOVFF  78,8F
028F4:  MOVFF  77,8E
028F8:  MOVFF  76,8D
028FC:  MOVFF  75,8C
02900:  MOVLW  02
02902:  MOVWF  x90
02904:  CALL   1CFC
....................       lcd_gotoxy(1,3); printf(lcd_putc," C2 = %f",R2);       
02908:  MOVLW  01
0290A:  MOVWF  x9A
0290C:  MOVLW  03
0290E:  MOVWF  x9B
02910:  CALL   0E36
02914:  CLRF   x8B
02916:  MOVF   x8B,W
02918:  CALL   0354
0291C:  INCF   x8B,F
0291E:  MOVWF  00
02920:  MOVWF  x99
02922:  CALL   0EA0
02926:  MOVLW  06
02928:  SUBWF  x8B,W
0292A:  BNZ   2916
0292C:  MOVLW  89
0292E:  MOVWF  FE9
02930:  MOVFF  7C,8F
02934:  MOVFF  7B,8E
02938:  MOVFF  7A,8D
0293C:  MOVFF  79,8C
02940:  MOVLW  02
02942:  MOVWF  x90
02944:  CALL   1CFC
....................       lcd_gotoxy(1,4); printf(lcd_putc," C3 = %f",R3);            
02948:  MOVLW  01
0294A:  MOVWF  x9A
0294C:  MOVLW  04
0294E:  MOVWF  x9B
02950:  CALL   0E36
02954:  CLRF   x8B
02956:  MOVF   x8B,W
02958:  CALL   037C
0295C:  INCF   x8B,F
0295E:  MOVWF  00
02960:  MOVWF  x99
02962:  CALL   0EA0
02966:  MOVLW  06
02968:  SUBWF  x8B,W
0296A:  BNZ   2956
0296C:  MOVLW  89
0296E:  MOVWF  FE9
02970:  MOVFF  80,8F
02974:  MOVFF  7F,8E
02978:  MOVFF  7E,8D
0297C:  MOVFF  7D,8C
02980:  MOVLW  02
02982:  MOVWF  x90
02984:  CALL   1CFC
....................              
....................        /// Adjudge Coils Value 
....................       if ( (R1 >= SPEC.C1l) && (R1 <= SPEC.C1h) )  
02988:  MOVFF  1F,8C
0298C:  MOVFF  1E,8B
02990:  CALL   1758
02994:  MOVFF  03,8E
02998:  MOVFF  02,8D
0299C:  MOVFF  01,8C
029A0:  MOVFF  00,8B
029A4:  MOVFF  78,92
029A8:  MOVFF  77,91
029AC:  MOVFF  76,90
029B0:  MOVFF  75,8F
029B4:  CALL   1E82
029B8:  BC    29BC
029BA:  BNZ   29F4
029BC:  MOVFF  1D,8C
029C0:  MOVFF  1C,8B
029C4:  CALL   1758
029C8:  MOVFF  78,8E
029CC:  MOVFF  77,8D
029D0:  MOVFF  76,8C
029D4:  MOVFF  75,8B
029D8:  MOVFF  03,92
029DC:  MOVFF  02,91
029E0:  MOVFF  01,90
029E4:  MOVFF  00,8F
029E8:  CALL   1E82
029EC:  BC    29F0
029EE:  BNZ   29F4
....................            r1_flag = TRUE; 
029F0:  BSF    x89.0
....................       else r1_flag = FALSE; 
029F2:  BRA    29F6
029F4:  BCF    x89.0
....................              
....................       if ( (R2 >= SPEC.C2l) && (R2 <= SPEC.C2h) ) 
029F6:  MOVFF  23,8C
029FA:  MOVFF  22,8B
029FE:  CALL   1758
02A02:  MOVFF  03,8E
02A06:  MOVFF  02,8D
02A0A:  MOVFF  01,8C
02A0E:  MOVFF  00,8B
02A12:  MOVFF  7C,92
02A16:  MOVFF  7B,91
02A1A:  MOVFF  7A,90
02A1E:  MOVFF  79,8F
02A22:  CALL   1E82
02A26:  BC    2A2A
02A28:  BNZ   2A62
02A2A:  MOVFF  21,8C
02A2E:  MOVFF  20,8B
02A32:  CALL   1758
02A36:  MOVFF  7C,8E
02A3A:  MOVFF  7B,8D
02A3E:  MOVFF  7A,8C
02A42:  MOVFF  79,8B
02A46:  MOVFF  03,92
02A4A:  MOVFF  02,91
02A4E:  MOVFF  01,90
02A52:  MOVFF  00,8F
02A56:  CALL   1E82
02A5A:  BC    2A5E
02A5C:  BNZ   2A62
....................            r2_flag = TRUE; 
02A5E:  BSF    x89.1
....................       else r2_flag = FALSE; 
02A60:  BRA    2A64
02A62:  BCF    x89.1
....................        
....................      if ( (R3 >= SPEC.C3l) && (R3 <= SPEC.C3h) ) 
02A64:  MOVFF  27,8C
02A68:  MOVFF  26,8B
02A6C:  CALL   1758
02A70:  MOVFF  03,8E
02A74:  MOVFF  02,8D
02A78:  MOVFF  01,8C
02A7C:  MOVFF  00,8B
02A80:  MOVFF  80,92
02A84:  MOVFF  7F,91
02A88:  MOVFF  7E,90
02A8C:  MOVFF  7D,8F
02A90:  CALL   1E82
02A94:  BC    2A98
02A96:  BNZ   2AD0
02A98:  MOVFF  25,8C
02A9C:  MOVFF  24,8B
02AA0:  CALL   1758
02AA4:  MOVFF  80,8E
02AA8:  MOVFF  7F,8D
02AAC:  MOVFF  7E,8C
02AB0:  MOVFF  7D,8B
02AB4:  MOVFF  03,92
02AB8:  MOVFF  02,91
02ABC:  MOVFF  01,90
02AC0:  MOVFF  00,8F
02AC4:  CALL   1E82
02AC8:  BC    2ACC
02ACA:  BNZ   2AD0
....................            r3_flag = TRUE; 
02ACC:  BSF    x89.2
....................       else r3_flag = FALSE; 
02ACE:  BRA    2AD2
02AD0:  BCF    x89.2
....................              
....................  
....................      output_low(RELAY) ; 
02AD2:  BCF    F89.3
....................      delay_ms(100) ;       
02AD4:  MOVLW  64
02AD6:  MOVWF  x9A
02AD8:  CALL   0C22
....................        
....................      if( (r1_flag == TRUE) && (r2_flag == TRUE) && (r3_flag == TRUE) ) 
02ADC:  BTFSS  x89.0
02ADE:  BRA    2B28
02AE0:  BTFSS  x89.1
02AE2:  BRA    2B28
02AE4:  BTFSS  x89.2
02AE6:  BRA    2B28
....................         { 
....................             Judge = AdjudgeCoils(0); 
02AE8:  CLRF   x8B
02AEA:  CALL   1F8C
02AEE:  BCF    x89.3
02AF0:  BTFSC  01.0
02AF2:  BSF    x89.3
....................             InsertData(R1,R2,R3); 
02AF4:  MOVFF  78,8E
02AF8:  MOVFF  77,8D
02AFC:  MOVFF  76,8C
02B00:  MOVFF  75,8B
02B04:  MOVFF  7C,92
02B08:  MOVFF  7B,91
02B0C:  MOVFF  7A,90
02B10:  MOVFF  79,8F
02B14:  MOVFF  80,96
02B18:  MOVFF  7F,95
02B1C:  MOVFF  7E,94
02B20:  MOVFF  7D,93
02B24:  BRA    236E
....................         } 
....................        
....................      else if( (r1_flag == FALSE) && (r2_flag == TRUE) && (r3_flag == TRUE) ) 
02B26:  BRA    2BEA
02B28:  BTFSC  x89.0
02B2A:  BRA    2B44
02B2C:  BTFSS  x89.1
02B2E:  BRA    2B44
02B30:  BTFSS  x89.2
02B32:  BRA    2B44
....................             Judge = AdjudgeCoils(1); 
02B34:  MOVLW  01
02B36:  MOVWF  x8B
02B38:  CALL   1F8C
02B3C:  BCF    x89.3
02B3E:  BTFSC  01.0
02B40:  BSF    x89.3
....................          
....................      else if( (r1_flag == TRUE) && (r2_flag == FALSE) && (r3_flag == TRUE) ) 
02B42:  BRA    2BEA
02B44:  BTFSS  x89.0
02B46:  BRA    2B60
02B48:  BTFSC  x89.1
02B4A:  BRA    2B60
02B4C:  BTFSS  x89.2
02B4E:  BRA    2B60
....................             Judge = AdjudgeCoils(2); 
02B50:  MOVLW  02
02B52:  MOVWF  x8B
02B54:  CALL   1F8C
02B58:  BCF    x89.3
02B5A:  BTFSC  01.0
02B5C:  BSF    x89.3
....................              
....................      else if( (r1_flag == TRUE) && (r2_flag == TRUE) && (r3_flag == FALSE) ) 
02B5E:  BRA    2BEA
02B60:  BTFSS  x89.0
02B62:  BRA    2B7C
02B64:  BTFSS  x89.1
02B66:  BRA    2B7C
02B68:  BTFSC  x89.2
02B6A:  BRA    2B7C
....................             Judge = AdjudgeCoils(3);        
02B6C:  MOVLW  03
02B6E:  MOVWF  x8B
02B70:  CALL   1F8C
02B74:  BCF    x89.3
02B76:  BTFSC  01.0
02B78:  BSF    x89.3
....................              
....................      else if( (r1_flag == FALSE) && (r2_flag == FALSE) && (r3_flag == TRUE) ) 
02B7A:  BRA    2BEA
02B7C:  BTFSC  x89.0
02B7E:  BRA    2B98
02B80:  BTFSC  x89.1
02B82:  BRA    2B98
02B84:  BTFSS  x89.2
02B86:  BRA    2B98
....................             Judge = AdjudgeCoils(4);   
02B88:  MOVLW  04
02B8A:  MOVWF  x8B
02B8C:  CALL   1F8C
02B90:  BCF    x89.3
02B92:  BTFSC  01.0
02B94:  BSF    x89.3
....................              
....................      else if( (r1_flag == FALSE) && (r2_flag == TRUE) && (r3_flag == FALSE) ) 
02B96:  BRA    2BEA
02B98:  BTFSC  x89.0
02B9A:  BRA    2BB4
02B9C:  BTFSS  x89.1
02B9E:  BRA    2BB4
02BA0:  BTFSC  x89.2
02BA2:  BRA    2BB4
....................             Judge = AdjudgeCoils(5); 
02BA4:  MOVLW  05
02BA6:  MOVWF  x8B
02BA8:  CALL   1F8C
02BAC:  BCF    x89.3
02BAE:  BTFSC  01.0
02BB0:  BSF    x89.3
....................              
....................      else if( (r1_flag == TRUE) && (r2_flag == FALSE) && (r3_flag == FALSE) ) 
02BB2:  BRA    2BEA
02BB4:  BTFSS  x89.0
02BB6:  BRA    2BD0
02BB8:  BTFSC  x89.1
02BBA:  BRA    2BD0
02BBC:  BTFSC  x89.2
02BBE:  BRA    2BD0
....................             Judge = AdjudgeCoils(6);        
02BC0:  MOVLW  06
02BC2:  MOVWF  x8B
02BC4:  CALL   1F8C
02BC8:  BCF    x89.3
02BCA:  BTFSC  01.0
02BCC:  BSF    x89.3
....................          
....................      else if( (r1_flag == FALSE) && (r2_flag == FALSE) && (r3_flag == FALSE) ) 
02BCE:  BRA    2BEA
02BD0:  BTFSC  x89.0
02BD2:  BRA    2BEA
02BD4:  BTFSC  x89.1
02BD6:  BRA    2BEA
02BD8:  BTFSC  x89.2
02BDA:  BRA    2BEA
....................             Judge = AdjudgeCoils(7); 
02BDC:  MOVLW  07
02BDE:  MOVWF  x8B
02BE0:  CALL   1F8C
02BE4:  BCF    x89.3
02BE6:  BTFSC  01.0
02BE8:  BSF    x89.3
....................       
....................       
....................       Value1 = 0; 
02BEA:  CLRF   x60
02BEC:  CLRF   5F
02BEE:  CLRF   5E
02BF0:  CLRF   5D
....................       Value2 = 0; 
02BF2:  CLRF   x64
02BF4:  CLRF   x63
02BF6:  CLRF   x62
02BF8:  CLRF   x61
....................       Value3 = 0; 
02BFA:  CLRF   x68
02BFC:  CLRF   x67
02BFE:  CLRF   x66
02C00:  CLRF   x65
....................       V1 = 0;  V2 = 0;  V3 = 0; 
02C02:  CLRF   x6C
02C04:  CLRF   x6B
02C06:  CLRF   x6A
02C08:  CLRF   x69
02C0A:  CLRF   x70
02C0C:  CLRF   x6F
02C0E:  CLRF   x6E
02C10:  CLRF   x6D
02C12:  CLRF   x74
02C14:  CLRF   x73
02C16:  CLRF   x72
02C18:  CLRF   x71
....................       R1 = 0;  R2 = 0;  R3 = 0; 
02C1A:  CLRF   x78
02C1C:  CLRF   x77
02C1E:  CLRF   x76
02C20:  CLRF   x75
02C22:  CLRF   x7C
02C24:  CLRF   x7B
02C26:  CLRF   x7A
02C28:  CLRF   x79
02C2A:  CLRF   x80
02C2C:  CLRF   x7F
02C2E:  CLRF   x7E
02C30:  CLRF   x7D
....................  
....................      Return(Judge); 
02C32:  MOVLW  00
02C34:  BTFSC  x89.3
02C36:  MOVLW  01
02C38:  MOVWF  01
.................... } 
02C3A:  RETLW  00
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CHECK SCREW ON SHUTTER 
.................... boolean Check_Screw(void) 
.................... { 
....................   boolean resp = FALSE; 
*
04338:  BCF    5D.0
....................     
....................    switch(SPEC.TypeScr) 
....................       { 
0433A:  MOVF   29,W
0433C:  XORLW  01
0433E:  BZ    4346
04340:  XORLW  03
04342:  BZ    43BA
04344:  BRA    43BE
....................          case 1:   
....................                  if( (!input(SS_SCREW1)) && (!input(SS_SCREW2)) && (!input(SS_SCREW3))  
....................                     && (!input(SS_SCREW4)) ) 
04346:  BTFSC  F85.2
04348:  BRA    435A
0434A:  BTFSC  F85.3
0434C:  BRA    435A
0434E:  BTFSC  F85.4
04350:  BRA    435A
04352:  BTFSC  F85.5
04354:  BRA    435A
....................                         resp = TRUE; 
04356:  BSF    5D.0
....................                  else    
04358:  BRA    43B8
....................                  { 
....................                      Clear_LCD(); delay_ms(100); 
0435A:  CALL   0EE4
0435E:  MOVLW  64
04360:  MOVWF  x9A
04362:  CALL   0C22
....................                      LED_RED(); 
04366:  CALL   1602
....................                      lcd_gotoxy(1,1); printf(lcd_putc,"Coils is OK          "); 
0436A:  MOVLW  01
0436C:  MOVWF  x9A
0436E:  MOVWF  x9B
04370:  CALL   0E36
04374:  CLRF   5E
04376:  MOVF   5E,W
04378:  CALL   03A4
0437C:  INCF   5E,F
0437E:  MOVWF  00
04380:  MOVWF  x99
04382:  CALL   0EA0
04386:  MOVLW  15
04388:  SUBWF  5E,W
0438A:  BNZ   4376
....................                      lcd_gotoxy(1,1); printf(lcd_putc,"Screw is NG          "); 
0438C:  MOVLW  01
0438E:  MOVWF  x9A
04390:  MOVWF  x9B
04392:  CALL   0E36
04396:  CLRF   5E
04398:  MOVF   5E,W
0439A:  CALL   03D8
0439E:  INCF   5E,F
043A0:  MOVWF  00
043A2:  MOVWF  x99
043A4:  CALL   0EA0
043A8:  MOVLW  15
043AA:  SUBWF  5E,W
043AC:  BNZ   4398
....................                      Buzzer_Alarm(10); 
043AE:  MOVLW  0A
043B0:  MOVWF  x8D
043B2:  CALL   1618
....................                      resp = FALSE; 
043B6:  BCF    5D.0
....................                  } 
....................          break; 
043B8:  BRA    43C2
....................           
....................          case 2:  resp = TRUE; //Buzzer_Config(); 
043BA:  BSF    5D.0
....................          break; 
043BC:  BRA    43C2
....................           
....................          default: resp = TRUE; //Buzzer_Config(); 
043BE:  BSF    5D.0
....................          break; 
043C0:  BRA    43C2
....................       } 
....................        
....................    return(resp); 
043C2:  MOVLW  00
043C4:  BTFSC  5D.0
043C6:  MOVLW  01
043C8:  MOVWF  01
.................... } 
043CA:  GOTO   45B4 (RETURN)
....................  
....................  
....................  
.................... //************************** INSERT DATA TO COMPUTER FOR KEEP TO DATA BASE 
.................... void InsertData(float a, float b, float c) 
.................... {      
....................     //printf("[%f,%f,%f]\r",a,b,c); 
....................     printf("[%f\r",a); 
*
0236E:  MOVLW  5B
02370:  BTFSS  F9E.4
02372:  BRA    2370
02374:  MOVWF  FAD
02376:  MOVLW  89
02378:  MOVWF  FE9
0237A:  MOVFF  8E,9A
0237E:  MOVFF  8D,99
02382:  MOVFF  8C,98
02386:  MOVFF  8B,97
0238A:  MOVLW  02
0238C:  MOVWF  x9B
0238E:  RCALL  21E6
02390:  MOVLW  0D
02392:  BTFSS  F9E.4
02394:  BRA    2392
02396:  MOVWF  FAD
....................     printf("[%f\r",b); 
02398:  MOVLW  5B
0239A:  BTFSS  F9E.4
0239C:  BRA    239A
0239E:  MOVWF  FAD
023A0:  MOVLW  89
023A2:  MOVWF  FE9
023A4:  MOVFF  92,9A
023A8:  MOVFF  91,99
023AC:  MOVFF  90,98
023B0:  MOVFF  8F,97
023B4:  MOVLW  02
023B6:  MOVWF  x9B
023B8:  RCALL  21E6
023BA:  MOVLW  0D
023BC:  BTFSS  F9E.4
023BE:  BRA    23BC
023C0:  MOVWF  FAD
....................     printf("[%f\r",c); 
023C2:  MOVLW  5B
023C4:  BTFSS  F9E.4
023C6:  BRA    23C4
023C8:  MOVWF  FAD
023CA:  MOVLW  89
023CC:  MOVWF  FE9
023CE:  MOVFF  96,9A
023D2:  MOVFF  95,99
023D6:  MOVFF  94,98
023DA:  MOVFF  93,97
023DE:  MOVLW  02
023E0:  MOVWF  x9B
023E2:  RCALL  21E6
023E4:  MOVLW  0D
023E6:  BTFSS  F9E.4
023E8:  BRA    23E6
023EA:  MOVWF  FAD
.................... } 
023EC:  GOTO   2B26 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CHECK STATUS OF I/O FOR CONTROL PROCESS 
.................... void _StatusIO_(void) 
.................... {    
....................    sw = GetStatus_SS(SW_ID); 
*
02F3E:  MOVLW  70
02F40:  MOVWF  5E
02F42:  CALL   10AC
02F46:  MOVFF  01,2A
....................    //lcd_gotoxy(1,3); printf(lcd_putc,"SW %02X",sw); 
....................   
....................    switch(sw) 
....................    {            
02F4A:  MOVF   2A,W
02F4C:  XORLW  78
02F4E:  BZ    2F6E
02F50:  XORLW  A0
02F52:  BZ    300A
02F54:  XORLW  60
02F56:  BTFSC  FD8.2
02F58:  BRA    306C
02F5A:  XORLW  50
02F5C:  BTFSC  FD8.2
02F5E:  BRA    30CE
02F60:  XORLW  18
02F62:  BTFSC  FD8.2
02F64:  BRA    3132
02F66:  XORLW  AF
02F68:  BTFSC  FD8.2
02F6A:  BRA    31C2
02F6C:  BRA    31E4
....................       case 0x78: //-- TEST SILINER ON A-XIS PIN AND GT.  (Blue Switch) >> 
....................                   delay_ms(200); 
02F6E:  MOVLW  C8
02F70:  MOVWF  x9A
02F72:  CALL   0C22
....................                   while( sw == 0x78) { sw = GetStatus_SS(SW_ID); } 
02F76:  MOVF   2A,W
02F78:  SUBLW  78
02F7A:  BNZ   2F8A
02F7C:  MOVLW  70
02F7E:  MOVWF  5E
02F80:  CALL   10AC
02F84:  MOVFF  01,2A
02F88:  BRA    2F76
....................                   if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
....................                       (!input(SS_QR_UP)) && (!input(SS_L))  ) 
02F8A:  BTFSC  F86.0
02F8C:  BRA    2FC8
02F8E:  BTFSC  F81.5
02F90:  BRA    2FC8
02F92:  BTFSC  F81.3
02F94:  BRA    2FC8
02F96:  BTFSC  F82.2
02F98:  BRA    2FC8
02F9A:  BTFSC  F85.0
02F9C:  BRA    2FC8
....................                          { 
....................                               if(MOVE_RIGHT() == TRUE) 
02F9E:  CALL   1654
02FA2:  DECFSZ 01,W
02FA4:  BRA    2FC6
....................                               { 
....................                                  delay_ms(750); 
02FA6:  MOVLW  03
02FA8:  MOVWF  5D
02FAA:  MOVLW  FA
02FAC:  MOVWF  x9A
02FAE:  CALL   0C22
02FB2:  DECFSZ 5D,F
02FB4:  BRA    2FAA
....................                                  if(MOVE_PIN() == TRUE) 
02FB6:  CALL   16C0
02FBA:  DECFSZ 01,W
02FBC:  BRA    2FC6
....................                                  { 
....................                                     MOVE_GT(); 
02FBE:  CALL   170C
....................                                     Resistance3(); 
02FC2:  CALL   23F0
....................                                  } 
....................                               } 
....................                          } 
....................                   else if( (!input(SS_COIL_DOWN)) && (!input(SS_STAMP_UP)) &&  
02FC6:  BRA    3008
....................                            (!input(SS_UNLOCK)) && (!input(SS_QR_UP))  && (!input(SS_R)) )  
02FC8:  BTFSC  F84.7
02FCA:  BRA    2FFC
02FCC:  BTFSC  F81.5
02FCE:  BRA    2FFC
02FD0:  BTFSC  F81.3
02FD2:  BRA    2FFC
02FD4:  BTFSC  F82.2
02FD6:  BRA    2FFC
02FD8:  BTFSC  F85.1
02FDA:  BRA    2FFC
....................                          { 
....................                               if(ORIGIN_PIN() == TRUE) 
02FDC:  RCALL  2C3C
02FDE:  DECFSZ 01,W
02FE0:  BRA    2FFA
....................                               { 
....................                                  if(ORIGIN_GT() == TRUE) 
02FE2:  RCALL  2C8E
02FE4:  DECFSZ 01,W
02FE6:  BRA    2FFA
....................                                  { 
....................                                     delay_ms(750); 
02FE8:  MOVLW  03
02FEA:  MOVWF  5D
02FEC:  MOVLW  FA
02FEE:  MOVWF  x9A
02FF0:  CALL   0C22
02FF4:  DECFSZ 5D,F
02FF6:  BRA    2FEC
....................                                     MOVE_LEFT(); 
02FF8:  RCALL  2CE0
....................                                  } 
....................                               } 
....................                          } 
....................                   else 
02FFA:  BRA    3008
....................                      { 
....................                         Display_CylinderError(); 
02FFC:  CALL   15C0
....................                         Buzzer_Alarm(10); 
03000:  MOVLW  0A
03002:  MOVWF  x8D
03004:  CALL   1618
....................                      }                  
....................       break; 
03008:  BRA    31E4
....................        
....................       case 0xD8: //-- TEST SILINDER ON A-XIS STAMP. (White Switch)  >>>> 
....................                   delay_ms(200); 
0300A:  MOVLW  C8
0300C:  MOVWF  x9A
0300E:  CALL   0C22
....................                   while( sw == 0xD8) { sw = GetStatus_SS(SW_ID); } 
03012:  MOVF   2A,W
03014:  SUBLW  D8
03016:  BNZ   3026
03018:  MOVLW  70
0301A:  MOVWF  5E
0301C:  CALL   10AC
03020:  MOVFF  01,2A
03024:  BRA    3012
....................                   if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_L)) )                          
03026:  BTFSC  F86.0
03028:  BRA    3042
0302A:  BTFSC  F81.5
0302C:  BRA    3042
0302E:  BTFSC  F81.3
03030:  BRA    3042
03032:  BTFSC  F82.2
03034:  BRA    3042
03036:  BTFSS  F86.3
03038:  BRA    3042
0303A:  BTFSC  F85.0
0303C:  BRA    3042
....................                          MOVE_STAMP(); 
0303E:  RCALL  2D52
....................                   else if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_DOWN)) && (!input(SS_UNLOCK)) && 
03040:  BRA    306A
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_L)) )  
03042:  BTFSC  F86.0
03044:  BRA    305E
03046:  BTFSC  F81.4
03048:  BRA    305E
0304A:  BTFSC  F81.3
0304C:  BRA    305E
0304E:  BTFSC  F82.2
03050:  BRA    305E
03052:  BTFSS  F86.3
03054:  BRA    305E
03056:  BTFSC  F85.0
03058:  BRA    305E
....................                          ORIGIN_STAMP(); 
0305A:  RCALL  2DA4
....................                   else 
0305C:  BRA    306A
....................                      { 
....................                         Display_CylinderError(); 
0305E:  CALL   15C0
....................                         Buzzer_Alarm(10); 
03062:  MOVLW  0A
03064:  MOVWF  x8D
03066:  CALL   1618
....................                      } 
....................  
....................       break;    
0306A:  BRA    31E4
....................        
....................       case 0xB8: //-- TEST SILINDER ON A-XIS QR CODE . (Red Switch) >>> 
....................                   delay_ms(200); 
0306C:  MOVLW  C8
0306E:  MOVWF  x9A
03070:  CALL   0C22
....................                   while( sw == 0xB8) { sw = GetStatus_SS(SW_ID); } 
03074:  MOVF   2A,W
03076:  SUBLW  B8
03078:  BNZ   3088
0307A:  MOVLW  70
0307C:  MOVWF  5E
0307E:  CALL   10AC
03082:  MOVFF  01,2A
03086:  BRA    3074
....................                   if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_L)) ) 
03088:  BTFSC  F86.0
0308A:  BRA    30A4
0308C:  BTFSC  F81.5
0308E:  BRA    30A4
03090:  BTFSC  F81.3
03092:  BRA    30A4
03094:  BTFSC  F82.2
03096:  BRA    30A4
03098:  BTFSS  F86.3
0309A:  BRA    30A4
0309C:  BTFSC  F85.0
0309E:  BRA    30A4
....................                          MOVE_QR(); 
030A0:  RCALL  2DF6
....................                   else if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
030A2:  BRA    30CC
....................                       (!input(SS_QR_DOWN)) && (input(SS_SCREW_UP)) && (!input(SS_L)) )  
030A4:  BTFSC  F86.0
030A6:  BRA    30C0
030A8:  BTFSC  F81.5
030AA:  BRA    30C0
030AC:  BTFSC  F81.3
030AE:  BRA    30C0
030B0:  BTFSC  F82.1
030B2:  BRA    30C0
030B4:  BTFSS  F86.3
030B6:  BRA    30C0
030B8:  BTFSC  F85.0
030BA:  BRA    30C0
....................                          ORIGIN_QR(); 
030BC:  RCALL  2E48
....................                   else 
030BE:  BRA    30CC
....................                      { 
....................                         Display_CylinderError(); 
030C0:  CALL   15C0
....................                         Buzzer_Alarm(10); 
030C4:  MOVLW  0A
030C6:  MOVWF  x8D
030C8:  CALL   1618
....................                      } 
....................       break;  
030CC:  BRA    31E4
....................        
....................       case 0xE8: //-- TEST SILINDER MOVE CHECK ON A-XIS X  (Yellow Switch) 
....................                   delay_ms(200); 
030CE:  MOVLW  C8
030D0:  MOVWF  x9A
030D2:  CALL   0C22
....................                   while( sw == 0xE8) { sw = GetStatus_SS(SW_ID); } 
030D6:  MOVF   2A,W
030D8:  SUBLW  E8
030DA:  BNZ   30EA
030DC:  MOVLW  70
030DE:  MOVWF  5E
030E0:  CALL   10AC
030E4:  MOVFF  01,2A
030E8:  BRA    30D6
....................                   if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_L)) ) 
030EA:  BTFSC  F86.0
030EC:  BRA    3108
030EE:  BTFSC  F81.5
030F0:  BRA    3108
030F2:  BTFSC  F81.3
030F4:  BRA    3108
030F6:  BTFSC  F82.2
030F8:  BRA    3108
030FA:  BTFSS  F86.3
030FC:  BRA    3108
030FE:  BTFSC  F85.0
03100:  BRA    3108
....................                          MOVE_RIGHT(); 
03102:  CALL   1654
....................                   else if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
03106:  BRA    3130
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_R)) )  
03108:  BTFSC  F86.0
0310A:  BRA    3124
0310C:  BTFSC  F81.5
0310E:  BRA    3124
03110:  BTFSC  F81.3
03112:  BRA    3124
03114:  BTFSC  F82.2
03116:  BRA    3124
03118:  BTFSS  F86.3
0311A:  BRA    3124
0311C:  BTFSC  F85.1
0311E:  BRA    3124
....................                          MOVE_LEFT(); 
03120:  RCALL  2CE0
....................                   else 
03122:  BRA    3130
....................                      { 
....................                         Display_CylinderError(); 
03124:  CALL   15C0
....................                         Buzzer_Alarm(10); 
03128:  MOVLW  0A
0312A:  MOVWF  x8D
0312C:  CALL   1618
....................                      } 
....................       break;     
03130:  BRA    31E4
....................        
....................       case 0xF0: //-- TEST SILINDER ON A-XIS BLOCK   (Black Switch) 
....................                   delay_ms(200); 
03132:  MOVLW  C8
03134:  MOVWF  x9A
03136:  CALL   0C22
....................                   while( sw == 0xF0) { sw = GetStatus_SS(SW_ID); } 
0313A:  MOVF   2A,W
0313C:  SUBLW  F0
0313E:  BNZ   314E
03140:  MOVLW  70
03142:  MOVWF  5E
03144:  CALL   10AC
03148:  MOVFF  01,2A
0314C:  BRA    313A
....................                   if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_UNLOCK)) && 
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_L)) ) 
0314E:  BTFSC  F86.0
03150:  BRA    3182
03152:  BTFSC  F81.5
03154:  BRA    3182
03156:  BTFSC  F81.3
03158:  BRA    3182
0315A:  BTFSC  F82.2
0315C:  BRA    3182
0315E:  BTFSS  F86.3
03160:  BRA    3182
03162:  BTFSC  F85.0
03164:  BRA    3182
....................                      { 
....................                         if(MOVE_RIGHT() == TRUE) 
03166:  CALL   1654
0316A:  DECFSZ 01,W
0316C:  BRA    3180
....................                         { 
....................                            delay_ms(550); 
0316E:  MOVLW  05
03170:  MOVWF  5D
03172:  MOVLW  6E
03174:  MOVWF  x9A
03176:  CALL   0C22
0317A:  DECFSZ 5D,F
0317C:  BRA    3172
....................                            MOVE_BLOCK(); 
0317E:  RCALL  2E9A
....................                         } 
....................                      } 
....................                   else if( (!input(SS_COIL_UP)) && (!input(SS_STAMP_UP)) && (!input(SS_LOCK)) && 
03180:  BRA    31C0
....................                       (!input(SS_QR_UP)) && (input(SS_SCREW_UP)) && (!input(SS_R)) )  
03182:  BTFSC  F86.0
03184:  BRA    31B4
03186:  BTFSC  F81.5
03188:  BRA    31B4
0318A:  BTFSC  F81.2
0318C:  BRA    31B4
0318E:  BTFSC  F82.2
03190:  BRA    31B4
03192:  BTFSS  F86.3
03194:  BRA    31B4
03196:  BTFSC  F85.1
03198:  BRA    31B4
....................                         { 
....................                            if(ORIGIN_BLOCK() == TRUE) 
0319A:  RCALL  2EEC
0319C:  DECFSZ 01,W
0319E:  BRA    31B2
....................                            { 
....................                               delay_ms(350); 
031A0:  MOVLW  02
031A2:  MOVWF  5D
031A4:  MOVLW  AF
031A6:  MOVWF  x9A
031A8:  CALL   0C22
031AC:  DECFSZ 5D,F
031AE:  BRA    31A4
....................                               MOVE_LEFT(); 
031B0:  RCALL  2CE0
....................                            } 
....................                         } 
....................                   else 
031B2:  BRA    31C0
....................                      { 
....................                         Display_CylinderError(); 
031B4:  CALL   15C0
....................                         Buzzer_Alarm(10); 
031B8:  MOVLW  0A
031BA:  MOVWF  x8D
031BC:  CALL   1618
....................                      } 
....................       break;  
031C0:  BRA    31E4
....................        
....................       case 0x5F: //-- Access Mode Setting Spec And JudgeMent Spec 
....................                   delay_ms(200); 
031C2:  MOVLW  C8
031C4:  MOVWF  x9A
031C6:  CALL   0C22
....................                   while( sw == 0x5F) { sw = GetStatus_SS(SW_ID); } 
031CA:  MOVF   2A,W
031CC:  SUBLW  5F
031CE:  BNZ   31DE
031D0:  MOVLW  70
031D2:  MOVWF  5E
031D4:  CALL   10AC
031D8:  MOVFF  01,2A
031DC:  BRA    31CA
....................                   Rob.ModeI = 1; 
031DE:  MOVLW  01
031E0:  MOVWF  1B
....................       break;        
031E2:  BRA    31E4
....................    } 
....................     
....................       
.................... } 
031E4:  GOTO   48F6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   STAMP SHUTTER ONLY 
.................... void StampOnly(void) 
.................... { 
....................   if(MOVE_RIGHT() == TRUE) 
*
044D6:  CALL   1654
044DA:  DECFSZ 01,W
044DC:  BRA    4570
....................    { 
....................       delay_ms(350); 
044DE:  MOVLW  02
044E0:  MOVWF  5D
044E2:  MOVLW  AF
044E4:  MOVWF  x9A
044E6:  CALL   0C22
044EA:  DECFSZ 5D,F
044EC:  BRA    44E2
....................       if(MOVE_BLOCK() == TRUE) 
044EE:  CALL   2E9A
044F2:  DECFSZ 01,W
044F4:  BRA    4570
....................       { 
....................          delay_ms(250); 
044F6:  MOVLW  FA
044F8:  MOVWF  x9A
044FA:  CALL   0C22
....................          if(MOVE_LEFT2() == TRUE) 
044FE:  BRA    43E6
04500:  DECFSZ 01,W
04502:  BRA    4570
....................          { 
....................             delay_ms(500); 
04504:  MOVLW  02
04506:  MOVWF  5D
04508:  MOVLW  FA
0450A:  MOVWF  x9A
0450C:  CALL   0C22
04510:  DECFSZ 5D,F
04512:  BRA    4508
....................             if(MOVE_STAMP() == TRUE) 
04514:  CALL   2D52
04518:  DECFSZ 01,W
0451A:  BRA    4570
....................             { 
....................                //delay_ms(200); 
....................                if(ORIGIN_STAMP() == TRUE) 
0451C:  CALL   2DA4
04520:  DECFSZ 01,W
04522:  BRA    4570
....................                { 
....................                   //delay_ms(100); 
....................                   if(MOVE_RIGHT2() == TRUE) 
04524:  BRA    4452
04526:  DECFSZ 01,W
04528:  BRA    4570
....................                   { 
....................                      delay_ms(250); 
0452A:  MOVLW  FA
0452C:  MOVWF  x9A
0452E:  CALL   0C22
....................                      if(ORIGIN_BLOCK() == TRUE) 
04532:  CALL   2EEC
04536:  DECFSZ 01,W
04538:  BRA    4570
....................                      { 
....................                         delay_ms(250); 
0453A:  MOVLW  FA
0453C:  MOVWF  x9A
0453E:  CALL   0C22
....................                         if(MOVE_LEFT() == TRUE) 
04542:  CALL   2CE0
04546:  DECFSZ 01,W
04548:  BRA    4570
....................                         { 
....................                            delay_ms(500); 
0454A:  MOVLW  02
0454C:  MOVWF  5D
0454E:  MOVLW  FA
04550:  MOVWF  x9A
04552:  CALL   0C22
04556:  DECFSZ 5D,F
04558:  BRA    454E
....................                            if(MOVE_STAMP() == TRUE) 
0455A:  CALL   2D52
0455E:  DECFSZ 01,W
04560:  BRA    4570
....................                            { 
....................                              ORIGIN_STAMP(); 
04562:  CALL   2DA4
....................                              Trig_Counter(); delay_ms(150);                               
04566:  BRA    44BE
04568:  MOVLW  96
0456A:  MOVWF  x9A
0456C:  CALL   0C22
....................                            } 
....................                         } 
....................                      } 
....................                   } 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
04570:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   INITIAL SENSOR 
.................... void Initial_SenSor(void)  
.................... { 
....................    Rob.Display_Spec = TRUE; 
*
00D24:  BSF    19.1
.................... } 
00D26:  GOTO   0D78 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------    
.................... void OperateAll(void) 
.................... {   
....................    if(MOVE_RIGHT() == TRUE) 
*
045CE:  CALL   1654
045D2:  DECFSZ 01,W
045D4:  BRA    4678
....................    { 
....................       delay_ms(500); 
045D6:  MOVLW  02
045D8:  MOVWF  5D
045DA:  MOVLW  FA
045DC:  MOVWF  x9A
045DE:  CALL   0C22
045E2:  DECFSZ 5D,F
045E4:  BRA    45DA
....................       if(MOVE_QR() == TRUE) 
045E6:  CALL   2DF6
045EA:  DECFSZ 01,W
045EC:  BRA    4678
....................       { 
....................          delay_ms(270); 
045EE:  MOVLW  02
045F0:  MOVWF  5D
045F2:  MOVLW  87
045F4:  MOVWF  x9A
045F6:  CALL   0C22
045FA:  DECFSZ 5D,F
045FC:  BRA    45F2
....................          printf("%s",QR_Packet); 
045FE:  CLRF   FEA
04600:  MOVLW  2B
04602:  MOVWF  FE9
04604:  MOVLW  00
04606:  IORWF  FEF,W
04608:  BZ    461A
0460A:  MOVF   FEF,W
0460C:  BTFSS  F9E.4
0460E:  BRA    460C
04610:  MOVWF  FAD
04612:  INCF   FE9,F
04614:  BTFSC  FD8.2
04616:  INCF   FEA,F
04618:  BRA    4604
....................          Rob.Ack_Qr = FALSE; 
0461A:  BCF    19.4
....................          if(ORIGIN_QR() == TRUE) 
0461C:  CALL   2E48
04620:  DECFSZ 01,W
04622:  BRA    4678
....................          {                
....................               delay_ms(990); 
04624:  MOVLW  05
04626:  MOVWF  5D
04628:  MOVLW  C6
0462A:  MOVWF  x9A
0462C:  CALL   0C22
04630:  DECFSZ 5D,F
04632:  BRA    4628
....................               if(Rob.Get_Qr == TRUE) 
04634:  BTFSS  19.3
04636:  BRA    463E
....................                { 
....................                    Rob.Get_Qr = FALSE;                                                          
04638:  BCF    19.3
....................                    Check_R_Stamp(); 
0463A:  RCALL  4572
....................                } 
....................                 
....................                else 
0463C:  BRA    4678
....................                { 
....................                   LED_RED(); 
0463E:  CALL   1602
....................                   Clear_LCD(); delay_ms(200);                           // 
04642:  CALL   0EE4
04646:  MOVLW  C8
04648:  MOVWF  x9A
0464A:  CALL   0C22
....................                   lcd_gotoxy(1,1); printf(lcd_putc,"QR Code is NG...    "); 
0464E:  MOVLW  01
04650:  MOVWF  x9A
04652:  MOVWF  x9B
04654:  CALL   0E36
04658:  CLRF   5D
0465A:  MOVF   5D,W
0465C:  CALL   040C
04660:  INCF   5D,F
04662:  MOVWF  00
04664:  MOVWF  x99
04666:  CALL   0EA0
0466A:  MOVLW  14
0466C:  SUBWF  5D,W
0466E:  BNZ   465A
....................                   Buzzer_Alarm(10); 
04670:  MOVLW  0A
04672:  MOVWF  x8D
04674:  CALL   1618
....................                } 
....................              
....................          } 
....................       } 
....................    } 
.................... } 
04678:  GOTO   4788 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------    
.................... void Check_R_Stamp(void) 
.................... {         
....................    if(MOVE_RIGHT() == TRUE) 
*
04572:  CALL   1654
04576:  DECFSZ 01,W
04578:  BRA    45CC
....................    { 
....................       delay_ms(550); 
0457A:  MOVLW  05
0457C:  MOVWF  5D
0457E:  MOVLW  6E
04580:  MOVWF  x9A
04582:  CALL   0C22
04586:  DECFSZ 5D,F
04588:  BRA    457E
....................       if(MOVE_PIN() == TRUE) 
0458A:  CALL   16C0
0458E:  DECFSZ 01,W
04590:  BRA    45CC
....................       { 
....................          delay_ms(150); 
04592:  MOVLW  96
04594:  MOVWF  x9A
04596:  CALL   0C22
....................          if(MOVE_GT() == TRUE) 
0459A:  CALL   170C
0459E:  DECFSZ 01,W
045A0:  BRA    45CC
....................          { 
....................             Rob.ResCoils = Resistance3(); 
045A2:  CALL   23F0
045A6:  BCF    19.5
045A8:  BTFSC  01.0
045AA:  BSF    19.5
....................             //delay_ms(350); 
....................             if(Rob.ResCoils == TRUE) 
045AC:  BTFSS  19.5
045AE:  BRA    45CC
....................             { 
....................                Rob.ResCoils = FALSE; 
045B0:  BCF    19.5
....................                Rob.ResScrew = Check_Screw(); 
045B2:  BRA    4338
045B4:  BCF    19.6
045B6:  BTFSC  01.0
045B8:  BSF    19.6
....................                if(Rob.ResScrew == TRUE) 
045BA:  BTFSS  19.6
045BC:  BRA    45CC
....................                { 
....................                   Rob.ResScrew = FALSE; 
045BE:  BCF    19.6
....................                   ORIGIN_PIN(); ORIGIN_GT(); //delay_ms(350); 
045C0:  CALL   2C3C
045C4:  CALL   2C8E
....................                   LED_GREEN(); 
045C8:  BRA    43CE
....................                   StampOnly(); 
045CA:  RCALL  44D6
....................                } 
....................  
....................             } 
....................              
....................              
....................          } 
....................                            
....................       } 
....................    } 
.................... } 
045CC:  RETLW  00
....................  
....................  
.................... //****************************************************************************** 
.................... //****************  CLEAR STAGE OF ROBOT TO INITIAL 
.................... void Initial_StageRobot(void) 
.................... { 
....................    if( !input(SS_R) ) 
*
00D7C:  BTFSC  F85.1
00D7E:  BRA    0DBC
....................       { 
....................          output_low(SV_SLIDER); delay_ms(250); 
00D80:  BCF    F95.0
00D82:  BCF    F8C.0
00D84:  MOVLW  FA
00D86:  MOVWF  x9A
00D88:  RCALL  0C22
....................          output_high(SV_COILS); output_high(SV_SCREW);  output_high(SV_QR);   delay_ms(199); 
00D8A:  BCF    F95.4
00D8C:  BSF    F8C.4
00D8E:  BCF    F95.5
00D90:  BSF    F8C.5
00D92:  BCF    F95.3
00D94:  BSF    F8C.3
00D96:  MOVLW  C7
00D98:  MOVWF  x9A
00D9A:  RCALL  0C22
....................          output_high(SV_STAMP);  delay_ms(100);         output_high(SV_LOCK); delay_ms(150); 
00D9C:  BCF    F95.2
00D9E:  BSF    F8C.2
00DA0:  MOVLW  64
00DA2:  MOVWF  x9A
00DA4:  RCALL  0C22
00DA6:  BCF    F95.1
00DA8:  BSF    F8C.1
00DAA:  MOVLW  96
00DAC:  MOVWF  x9A
00DAE:  RCALL  0C22
....................          output_high(SV_SLIDER); delay_ms(100);          
00DB0:  BCF    F95.0
00DB2:  BSF    F8C.0
00DB4:  MOVLW  64
00DB6:  MOVWF  x9A
00DB8:  RCALL  0C22
....................       } 
....................        
....................    else if( !input(SS_L) ) 
00DBA:  BRA    0E22
00DBC:  BTFSC  F85.0
00DBE:  BRA    0DF2
....................       { 
....................          output_high(SV_COILS); output_high(SV_SCREW);  output_high(SV_QR);   delay_ms(199); 
00DC0:  BCF    F95.4
00DC2:  BSF    F8C.4
00DC4:  BCF    F95.5
00DC6:  BSF    F8C.5
00DC8:  BCF    F95.3
00DCA:  BSF    F8C.3
00DCC:  MOVLW  C7
00DCE:  MOVWF  x9A
00DD0:  RCALL  0C22
....................          output_high(SV_STAMP);  delay_ms(100);         output_high(SV_LOCK); delay_ms(150); 
00DD2:  BCF    F95.2
00DD4:  BSF    F8C.2
00DD6:  MOVLW  64
00DD8:  MOVWF  x9A
00DDA:  RCALL  0C22
00DDC:  BCF    F95.1
00DDE:  BSF    F8C.1
00DE0:  MOVLW  96
00DE2:  MOVWF  x9A
00DE4:  RCALL  0C22
....................          output_high(SV_SLIDER); delay_ms(100);         
00DE6:  BCF    F95.0
00DE8:  BSF    F8C.0
00DEA:  MOVLW  64
00DEC:  MOVWF  x9A
00DEE:  RCALL  0C22
....................       }        
....................        
....................    else  
00DF0:  BRA    0E22
....................       { 
....................          output_high(SV_COILS); output_high(SV_SCREW);  output_high(SV_QR);   delay_ms(199); 
00DF2:  BCF    F95.4
00DF4:  BSF    F8C.4
00DF6:  BCF    F95.5
00DF8:  BSF    F8C.5
00DFA:  BCF    F95.3
00DFC:  BSF    F8C.3
00DFE:  MOVLW  C7
00E00:  MOVWF  x9A
00E02:  RCALL  0C22
....................          output_high(SV_STAMP);  delay_ms(100);         output_high(SV_LOCK); delay_ms(150); 
00E04:  BCF    F95.2
00E06:  BSF    F8C.2
00E08:  MOVLW  64
00E0A:  MOVWF  x9A
00E0C:  RCALL  0C22
00E0E:  BCF    F95.1
00E10:  BSF    F8C.1
00E12:  MOVLW  96
00E14:  MOVWF  x9A
00E16:  RCALL  0C22
....................          output_high(SV_SLIDER); delay_ms(100);   
00E18:  BCF    F95.0
00E1A:  BSF    F8C.0
00E1C:  MOVLW  64
00E1E:  MOVWF  x9A
00E20:  RCALL  0C22
....................       } 
.................... } 
00E22:  GOTO   1536 (RETURN)
....................  
....................  
....................  
.................... #include <Gb_Spec.c> 
....................   
.................... //-----------------------  DEFINE VARIABLE 
....................  byte blink; 
....................  
.................... //****************************************************************************** 
.................... // -------------------------    FUCTION IN USE FOR SETTING SPEC 
....................  
.................... void Config_Type(void); 
.................... void Check_InterFace(void); 
....................  
.................... boolean Config_BaudRate(void); 
.................... void JudgeMent_BaudRate(void); 
.................... void Save_BaudRate(byte BR); 
.................... void Read_BaudRate(void); 
....................  
.................... boolean Setting_SpecCoils(void); 
.................... void Setting_Coils(void); 
.................... void Save_SpecCoils(void); 
.................... void Read_SpecCoils(void); 
....................  
.................... void Setting_Screw(void); 
.................... boolean Setting_SpecScrew(void); 
.................... void Save_TypeScrew(byte TypeChk); 
.................... void Read_TypeScrew(void); 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   JUDGEMENT BAUD RATE VALUE FOR INTERFACE BOXC WITH PC 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //-------------------   CHOOSE TYPE CONFIG < BAUDE RATE,SCREW AND COILS RESISTANCE > 
.................... void Config_Type(void) 
.................... { 
....................    static byte mode = 1; 
....................     
....................    sw = 0xFF; 
*
03F9C:  MOVLW  FF
03F9E:  MOVWF  2A
....................    lcd_gotoxy(1,1); printf(lcd_putc," Please select type "); 
03FA0:  MOVLW  01
03FA2:  MOVWF  x9A
03FA4:  MOVWF  x9B
03FA6:  CALL   0E36
03FAA:  CLRF   5D
03FAC:  MOVF   5D,W
03FAE:  CALL   0440
03FB2:  INCF   5D,F
03FB4:  MOVWF  00
03FB6:  MOVWF  x99
03FB8:  CALL   0EA0
03FBC:  MOVLW  14
03FBE:  SUBWF  5D,W
03FC0:  BNZ   3FAC
....................    Buzzer_LongBeep(); 
03FC2:  GOTO   31E8
....................    Start_Buzzer(); 
03FC6:  CALL   1500
....................    for(blink = 0; blink < 3; blink++) 
03FCA:  CLRF   57
03FCC:  MOVF   57,W
03FCE:  SUBLW  02
03FD0:  BNC   403E
....................       { 
....................          lcd_gotoxy(1,1); printf(lcd_putc,"                    "); delay_ms(300); 
03FD2:  MOVLW  01
03FD4:  MOVWF  x9A
03FD6:  MOVWF  x9B
03FD8:  CALL   0E36
03FDC:  CLRF   5D
03FDE:  MOVF   5D,W
03FE0:  CALL   01EE
03FE4:  INCF   5D,F
03FE6:  MOVWF  00
03FE8:  MOVFF  00,99
03FEC:  CALL   0EA0
03FF0:  MOVLW  14
03FF2:  SUBWF  5D,W
03FF4:  BNZ   3FDE
03FF6:  MOVLW  02
03FF8:  MOVWF  5D
03FFA:  MOVLW  96
03FFC:  MOVWF  x9A
03FFE:  CALL   0C22
04002:  DECFSZ 5D,F
04004:  BRA    3FFA
....................          lcd_gotoxy(1,1); printf(lcd_putc," Please select type "); delay_ms(300); 
04006:  MOVLW  01
04008:  MOVWF  x9A
0400A:  MOVWF  x9B
0400C:  CALL   0E36
04010:  CLRF   5D
04012:  MOVF   5D,W
04014:  CALL   0440
04018:  INCF   5D,F
0401A:  MOVWF  00
0401C:  MOVFF  00,99
04020:  CALL   0EA0
04024:  MOVLW  14
04026:  SUBWF  5D,W
04028:  BNZ   4012
0402A:  MOVLW  02
0402C:  MOVWF  5D
0402E:  MOVLW  96
04030:  MOVWF  x9A
04032:  CALL   0C22
04036:  DECFSZ 5D,F
04038:  BRA    402E
....................       } 
0403A:  INCF   57,F
0403C:  BRA    3FCC
....................        
....................    lcd_gotoxy(1,2); printf(lcd_putc,">> 1.Check Interface"); 
0403E:  MOVLW  01
04040:  MOVWF  x9A
04042:  MOVLW  02
04044:  MOVWF  x9B
04046:  CALL   0E36
0404A:  CLRF   5D
0404C:  MOVF   5D,W
0404E:  CALL   0474
04052:  INCF   5D,F
04054:  MOVWF  00
04056:  MOVWF  x99
04058:  CALL   0EA0
0405C:  MOVLW  14
0405E:  SUBWF  5D,W
04060:  BNZ   404C
....................    lcd_gotoxy(1,3); printf(lcd_putc,"   2.Setting Screw  "); 
04062:  MOVLW  01
04064:  MOVWF  x9A
04066:  MOVLW  03
04068:  MOVWF  x9B
0406A:  CALL   0E36
0406E:  CLRF   5D
04070:  MOVF   5D,W
04072:  CALL   04A8
04076:  INCF   5D,F
04078:  MOVWF  00
0407A:  MOVWF  x99
0407C:  CALL   0EA0
04080:  MOVLW  14
04082:  SUBWF  5D,W
04084:  BNZ   4070
....................    lcd_gotoxy(1,4); printf(lcd_putc,"   3.Setting Coils  "); 
04086:  MOVLW  01
04088:  MOVWF  x9A
0408A:  MOVLW  04
0408C:  MOVWF  x9B
0408E:  CALL   0E36
04092:  CLRF   5D
04094:  MOVF   5D,W
04096:  CALL   04DC
0409A:  INCF   5D,F
0409C:  MOVWF  00
0409E:  MOVWF  x99
040A0:  CALL   0EA0
040A4:  MOVLW  14
040A6:  SUBWF  5D,W
040A8:  BNZ   4094
....................    delay_ms(1100); 
040AA:  MOVLW  05
040AC:  MOVWF  5D
040AE:  MOVLW  DC
040B0:  MOVWF  x9A
040B2:  CALL   0C22
040B6:  DECFSZ 5D,F
040B8:  BRA    40AE
....................     
....................    while(sw != 0x7F)          //-- Wait until press button enter (Blue switch) 
....................    { 
040BA:  MOVF   2A,W
040BC:  SUBLW  7F
040BE:  BTFSC  FD8.2
040C0:  BRA    42AC
....................       sw = GetStatus_SS(SW_ID); 
040C2:  MOVLW  70
040C4:  MOVWF  5E
040C6:  CALL   10AC
040CA:  MOVFF  01,2A
....................       if(sw == 0xF7)       //--------------- Choose Mode Interface 
040CE:  MOVF   2A,W
040D0:  SUBLW  F7
040D2:  BNZ   416C
....................          { 
....................             delay_ms(100); 
040D4:  MOVLW  64
040D6:  MOVWF  x9A
040D8:  CALL   0C22
....................             while(sw == 0xF7) { sw = GetStatus_SS(SW_ID); } 
040DC:  MOVF   2A,W
040DE:  SUBLW  F7
040E0:  BNZ   40F0
040E2:  MOVLW  70
040E4:  MOVWF  5E
040E6:  CALL   10AC
040EA:  MOVFF  01,2A
040EE:  BRA    40DC
....................             mode = 1; 
040F0:  MOVLW  01
040F2:  MOVWF  58
....................             lcd_gotoxy(1,2); printf(lcd_putc,">> 1.Check Interface"); 
040F4:  MOVWF  x9A
040F6:  MOVLW  02
040F8:  MOVWF  x9B
040FA:  CALL   0E36
040FE:  CLRF   5D
04100:  MOVF   5D,W
04102:  CALL   0474
04106:  INCF   5D,F
04108:  MOVWF  00
0410A:  MOVWF  x99
0410C:  CALL   0EA0
04110:  MOVLW  14
04112:  SUBWF  5D,W
04114:  BNZ   4100
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   2.Setting Screw  "); 
04116:  MOVLW  01
04118:  MOVWF  x9A
0411A:  MOVLW  03
0411C:  MOVWF  x9B
0411E:  CALL   0E36
04122:  CLRF   5D
04124:  MOVF   5D,W
04126:  CALL   04A8
0412A:  INCF   5D,F
0412C:  MOVWF  00
0412E:  MOVWF  x99
04130:  CALL   0EA0
04134:  MOVLW  14
04136:  SUBWF  5D,W
04138:  BNZ   4124
....................             lcd_gotoxy(1,4); printf(lcd_putc,"   3.Setting Coils  "); delay_ms(10); 
0413A:  MOVLW  01
0413C:  MOVWF  x9A
0413E:  MOVLW  04
04140:  MOVWF  x9B
04142:  CALL   0E36
04146:  CLRF   5D
04148:  MOVF   5D,W
0414A:  CALL   04DC
0414E:  INCF   5D,F
04150:  MOVWF  00
04152:  MOVWF  x99
04154:  CALL   0EA0
04158:  MOVLW  14
0415A:  SUBWF  5D,W
0415C:  BNZ   4148
0415E:  MOVLW  0A
04160:  MOVWF  x9A
04162:  CALL   0C22
....................             Buzzer_Beep(); 
04166:  CALL   3208
....................          } 
....................           
....................       else if(sw == 0xEF)       //--------------- Choose Mode Screw check 
0416A:  BRA    42AA
0416C:  MOVF   2A,W
0416E:  SUBLW  EF
04170:  BNZ   420C
....................          { 
....................             delay_ms(100); 
04172:  MOVLW  64
04174:  MOVWF  x9A
04176:  CALL   0C22
....................             while(sw == 0xEF) { sw = GetStatus_SS(SW_ID); } 
0417A:  MOVF   2A,W
0417C:  SUBLW  EF
0417E:  BNZ   418E
04180:  MOVLW  70
04182:  MOVWF  5E
04184:  CALL   10AC
04188:  MOVFF  01,2A
0418C:  BRA    417A
....................             mode = 2; 
0418E:  MOVLW  02
04190:  MOVWF  58
....................             lcd_gotoxy(1,2); printf(lcd_putc,"   1.Check Interface"); 
04192:  MOVLW  01
04194:  MOVWF  x9A
04196:  MOVLW  02
04198:  MOVWF  x9B
0419A:  CALL   0E36
0419E:  CLRF   5D
041A0:  MOVF   5D,W
041A2:  CALL   0510
041A6:  INCF   5D,F
041A8:  MOVWF  00
041AA:  MOVWF  x99
041AC:  CALL   0EA0
041B0:  MOVLW  14
041B2:  SUBWF  5D,W
041B4:  BNZ   41A0
....................             lcd_gotoxy(1,3); printf(lcd_putc,">> 2.Setting Screw  "); 
041B6:  MOVLW  01
041B8:  MOVWF  x9A
041BA:  MOVLW  03
041BC:  MOVWF  x9B
041BE:  CALL   0E36
041C2:  CLRF   5D
041C4:  MOVF   5D,W
041C6:  CALL   0544
041CA:  INCF   5D,F
041CC:  MOVWF  00
041CE:  MOVWF  x99
041D0:  CALL   0EA0
041D4:  MOVLW  14
041D6:  SUBWF  5D,W
041D8:  BNZ   41C4
....................             lcd_gotoxy(1,4); printf(lcd_putc,"   3.Setting Coils  "); delay_ms(10); 
041DA:  MOVLW  01
041DC:  MOVWF  x9A
041DE:  MOVLW  04
041E0:  MOVWF  x9B
041E2:  CALL   0E36
041E6:  CLRF   5D
041E8:  MOVF   5D,W
041EA:  CALL   04DC
041EE:  INCF   5D,F
041F0:  MOVWF  00
041F2:  MOVWF  x99
041F4:  CALL   0EA0
041F8:  MOVLW  14
041FA:  SUBWF  5D,W
041FC:  BNZ   41E8
041FE:  MOVLW  0A
04200:  MOVWF  x9A
04202:  CALL   0C22
....................             Buzzer_Beep(); 
04206:  CALL   3208
....................          }    
....................           
....................       else if(sw == 0xDF)       //--------------- Choose Mode Coils Spec 
0420A:  BRA    42AA
0420C:  MOVF   2A,W
0420E:  SUBLW  DF
04210:  BNZ   42AA
....................          { 
....................             delay_ms(100); 
04212:  MOVLW  64
04214:  MOVWF  x9A
04216:  CALL   0C22
....................             while(sw == 0xDF) { sw = GetStatus_SS(SW_ID); } 
0421A:  MOVF   2A,W
0421C:  SUBLW  DF
0421E:  BNZ   422E
04220:  MOVLW  70
04222:  MOVWF  5E
04224:  CALL   10AC
04228:  MOVFF  01,2A
0422C:  BRA    421A
....................             mode = 3; 
0422E:  MOVLW  03
04230:  MOVWF  58
....................             lcd_gotoxy(1,2); printf(lcd_putc,"   1.Check Interface"); 
04232:  MOVLW  01
04234:  MOVWF  x9A
04236:  MOVLW  02
04238:  MOVWF  x9B
0423A:  CALL   0E36
0423E:  CLRF   5D
04240:  MOVF   5D,W
04242:  CALL   0510
04246:  INCF   5D,F
04248:  MOVWF  00
0424A:  MOVWF  x99
0424C:  CALL   0EA0
04250:  MOVLW  14
04252:  SUBWF  5D,W
04254:  BNZ   4240
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   2.Setting Screw  "); 
04256:  MOVLW  01
04258:  MOVWF  x9A
0425A:  MOVLW  03
0425C:  MOVWF  x9B
0425E:  CALL   0E36
04262:  CLRF   5D
04264:  MOVF   5D,W
04266:  CALL   04A8
0426A:  INCF   5D,F
0426C:  MOVWF  00
0426E:  MOVWF  x99
04270:  CALL   0EA0
04274:  MOVLW  14
04276:  SUBWF  5D,W
04278:  BNZ   4264
....................             lcd_gotoxy(1,4); printf(lcd_putc,">> 3.Setting Coils  "); delay_ms(10); 
0427A:  MOVLW  01
0427C:  MOVWF  x9A
0427E:  MOVLW  04
04280:  MOVWF  x9B
04282:  CALL   0E36
04286:  CLRF   5D
04288:  MOVF   5D,W
0428A:  CALL   0578
0428E:  INCF   5D,F
04290:  MOVWF  00
04292:  MOVWF  x99
04294:  CALL   0EA0
04298:  MOVLW  14
0429A:  SUBWF  5D,W
0429C:  BNZ   4288
0429E:  MOVLW  0A
042A0:  MOVWF  x9A
042A2:  CALL   0C22
....................             Buzzer_Beep(); 
042A6:  CALL   3208
....................          }   
....................    
....................    } 
042AA:  BRA    40BA
....................     
....................    sw = 0xFF; 
042AC:  MOVLW  FF
042AE:  MOVWF  2A
....................    delay_ms(350);  
042B0:  MOVLW  02
042B2:  MOVWF  5D
042B4:  MOVLW  AF
042B6:  MOVWF  x9A
042B8:  CALL   0C22
042BC:  DECFSZ 5D,F
042BE:  BRA    42B4
....................    Start_Buzzer(); 
042C0:  CALL   1500
....................    switch(mode) 
....................    {            
042C4:  MOVF   58,W
042C6:  XORLW  01
042C8:  BZ    42D4
042CA:  XORLW  03
042CC:  BZ    4302
042CE:  XORLW  01
042D0:  BZ    4306
042D2:  BRA    4308
....................       case 1:          
....................                Check_InterFace(); delay_ms(150); 
042D4:  CALL   13AC
042D8:  MOVLW  96
042DA:  MOVWF  x9A
042DC:  CALL   0C22
....................                sw = GetStatus_SS(SW_ID); 
042E0:  MOVLW  70
042E2:  MOVWF  5E
042E4:  CALL   10AC
042E8:  MOVFF  01,2A
....................                while( sw != 0x7F ) { sw = GetStatus_SS(SW_ID); } 
042EC:  MOVF   2A,W
042EE:  SUBLW  7F
042F0:  BZ    4300
042F2:  MOVLW  70
042F4:  MOVWF  5E
042F6:  CALL   10AC
042FA:  MOVFF  01,2A
042FE:  BRA    42EC
....................       break; 
04300:  BRA    4336
....................        
....................       case 2:  Setting_Screw();     
04302:  GOTO   358A
....................       break; 
....................        
....................       case 3:  Setting_Coils();     
04306:  BRA    3DEE
....................       break; 
....................        
....................       default:  
....................                Check_InterFace(); delay_ms(150); 
04308:  CALL   13AC
0430C:  MOVLW  96
0430E:  MOVWF  x9A
04310:  CALL   0C22
....................                sw = GetStatus_SS(SW_ID); 
04314:  MOVLW  70
04316:  MOVWF  5E
04318:  CALL   10AC
0431C:  MOVFF  01,2A
....................                while( sw != 0x7F ) { sw = GetStatus_SS(SW_ID); } 
04320:  MOVF   2A,W
04322:  SUBLW  7F
04324:  BZ    4334
04326:  MOVLW  70
04328:  MOVWF  5E
0432A:  CALL   10AC
0432E:  MOVFF  01,2A
04332:  BRA    4320
....................       break; 
04334:  BRA    4336
....................    } 
....................     
.................... } 
04336:  RETLW  00
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------    
.................... void Check_InterFace(void) 
.................... { 
....................     Clear_LCD(); delay_ms(200); 
*
013AC:  RCALL  0EE4
013AE:  MOVLW  C8
013B0:  MOVWF  x9A
013B2:  RCALL  0C22
....................     lcd_gotoxy(1,1); printf(lcd_putc,"  Screw & BaudRate  "); 
013B4:  MOVLW  01
013B6:  MOVWF  x9A
013B8:  MOVWF  x9B
013BA:  RCALL  0E36
013BC:  CLRF   5D
013BE:  MOVF   5D,W
013C0:  CALL   05AC
013C4:  INCF   5D,F
013C6:  MOVWF  00
013C8:  MOVWF  x99
013CA:  RCALL  0EA0
013CC:  MOVLW  14
013CE:  SUBWF  5D,W
013D0:  BNZ   13BE
....................     Read_TypeScrew(); 
013D2:  BRA    0F64
....................     lcd_gotoxy(1,3); printf(lcd_putc,"BaudRate: 19200 B/s "); 
013D4:  MOVLW  01
013D6:  MOVWF  x9A
013D8:  MOVLW  03
013DA:  MOVWF  x9B
013DC:  RCALL  0E36
013DE:  CLRF   5D
013E0:  MOVF   5D,W
013E2:  CALL   05E0
013E6:  INCF   5D,F
013E8:  MOVWF  00
013EA:  MOVWF  x99
013EC:  RCALL  0EA0
013EE:  MOVLW  14
013F0:  SUBWF  5D,W
013F2:  BNZ   13E0
....................      
....................     if(Rob.Display_Spec == FALSE) 
013F4:  BTFSC  19.1
013F6:  BRA    1414
....................     { 
....................        sw = GetStatus_SS(SW_ID); 
013F8:  MOVLW  70
013FA:  MOVWF  5E
013FC:  RCALL  10AC
013FE:  MOVFF  01,2A
....................        while( sw != 0x7F ) { sw = GetStatus_SS(SW_ID); } 
01402:  MOVF   2A,W
01404:  SUBLW  7F
01406:  BZ    1414
01408:  MOVLW  70
0140A:  MOVWF  5E
0140C:  RCALL  10AC
0140E:  MOVFF  01,2A
01412:  BRA    1402
....................     } 
....................      
....................     lcd_gotoxy(1,1); printf(lcd_putc,"Spec Coils 1-3...   "); 
01414:  MOVLW  01
01416:  MOVWF  x9A
01418:  MOVWF  x9B
0141A:  RCALL  0E36
0141C:  CLRF   5D
0141E:  MOVF   5D,W
01420:  CALL   0614
01424:  INCF   5D,F
01426:  MOVWF  00
01428:  MOVWF  x99
0142A:  RCALL  0EA0
0142C:  MOVLW  14
0142E:  SUBWF  5D,W
01430:  BNZ   141E
....................     lcd_gotoxy(1,2); printf(lcd_putc,"                    "); 
01432:  MOVLW  01
01434:  MOVWF  x9A
01436:  MOVLW  02
01438:  MOVWF  x9B
0143A:  RCALL  0E36
0143C:  CLRF   5D
0143E:  MOVF   5D,W
01440:  CALL   01EE
01444:  INCF   5D,F
01446:  MOVWF  00
01448:  MOVWF  x99
0144A:  RCALL  0EA0
0144C:  MOVLW  14
0144E:  SUBWF  5D,W
01450:  BNZ   143E
....................     lcd_gotoxy(1,3); printf(lcd_putc,"                    "); 
01452:  MOVLW  01
01454:  MOVWF  x9A
01456:  MOVLW  03
01458:  MOVWF  x9B
0145A:  RCALL  0E36
0145C:  CLRF   5D
0145E:  MOVF   5D,W
01460:  CALL   01EE
01464:  INCF   5D,F
01466:  MOVWF  00
01468:  MOVWF  x99
0146A:  RCALL  0EA0
0146C:  MOVLW  14
0146E:  SUBWF  5D,W
01470:  BNZ   145E
....................     Read_SpecCoils();     
01472:  BRA    11E0
.................... } 
01474:  RETLW  00
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SETTING SPEC OF SCREW 
.................... void Setting_Screw(void) 
.................... { 
....................       Rob.Reset_Flag   = FALSE; 
*
0358A:  BCF    19.0
....................       Rob.CompleteSpec = FALSE; 
0358C:  BCF    19.2
....................  
....................       lcd_gotoxy(1,1); printf(lcd_putc,"Choose mode check   "); 
0358E:  MOVLW  01
03590:  MOVWF  x9A
03592:  MOVWF  x9B
03594:  CALL   0E36
03598:  CLRF   5D
0359A:  MOVF   5D,W
0359C:  CALL   0648
035A0:  INCF   5D,F
035A2:  MOVWF  00
035A4:  MOVWF  x99
035A6:  CALL   0EA0
035AA:  MOVLW  14
035AC:  SUBWF  5D,W
035AE:  BNZ   359A
....................       for(blink = 0; blink < 3; blink++) 
035B0:  CLRF   57
035B2:  MOVF   57,W
035B4:  SUBLW  02
035B6:  BNC   3624
....................          { 
....................             lcd_gotoxy(1,1); printf(lcd_putc,"                    "); delay_ms(350); 
035B8:  MOVLW  01
035BA:  MOVWF  x9A
035BC:  MOVWF  x9B
035BE:  CALL   0E36
035C2:  CLRF   5D
035C4:  MOVF   5D,W
035C6:  CALL   01EE
035CA:  INCF   5D,F
035CC:  MOVWF  00
035CE:  MOVFF  00,99
035D2:  CALL   0EA0
035D6:  MOVLW  14
035D8:  SUBWF  5D,W
035DA:  BNZ   35C4
035DC:  MOVLW  02
035DE:  MOVWF  5D
035E0:  MOVLW  AF
035E2:  MOVWF  x9A
035E4:  CALL   0C22
035E8:  DECFSZ 5D,F
035EA:  BRA    35E0
....................             lcd_gotoxy(1,1); printf(lcd_putc,"Choose mode check   "); delay_ms(350); 
035EC:  MOVLW  01
035EE:  MOVWF  x9A
035F0:  MOVWF  x9B
035F2:  CALL   0E36
035F6:  CLRF   5D
035F8:  MOVF   5D,W
035FA:  CALL   0648
035FE:  INCF   5D,F
03600:  MOVWF  00
03602:  MOVFF  00,99
03606:  CALL   0EA0
0360A:  MOVLW  14
0360C:  SUBWF  5D,W
0360E:  BNZ   35F8
03610:  MOVLW  02
03612:  MOVWF  5D
03614:  MOVLW  AF
03616:  MOVWF  x9A
03618:  CALL   0C22
0361C:  DECFSZ 5D,F
0361E:  BRA    3614
....................          } 
03620:  INCF   57,F
03622:  BRA    35B2
....................           
....................             lcd_gotoxy(1,2); printf(lcd_putc,">> Check all screw  "); 
03624:  MOVLW  01
03626:  MOVWF  x9A
03628:  MOVLW  02
0362A:  MOVWF  x9B
0362C:  CALL   0E36
03630:  CLRF   5D
03632:  MOVF   5D,W
03634:  CALL   067C
03638:  INCF   5D,F
0363A:  MOVWF  00
0363C:  MOVWF  x99
0363E:  CALL   0EA0
03642:  MOVLW  14
03644:  SUBWF  5D,W
03646:  BNZ   3632
....................             delay_ms(50); 
03648:  MOVLW  32
0364A:  MOVWF  x9A
0364C:  CALL   0C22
....................              
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   Don't care all   "); 
03650:  MOVLW  01
03652:  MOVWF  x9A
03654:  MOVLW  03
03656:  MOVWF  x9B
03658:  CALL   0E36
0365C:  CLRF   5D
0365E:  MOVF   5D,W
03660:  CALL   06B0
03664:  INCF   5D,F
03666:  MOVWF  00
03668:  MOVWF  x99
0366A:  CALL   0EA0
0366E:  MOVLW  14
03670:  SUBWF  5D,W
03672:  BNZ   365E
....................             lcd_gotoxy(1,4); printf(lcd_putc,"                    "); 
03674:  MOVLW  01
03676:  MOVWF  x9A
03678:  MOVLW  04
0367A:  MOVWF  x9B
0367C:  CALL   0E36
03680:  CLRF   5D
03682:  MOVF   5D,W
03684:  CALL   01EE
03688:  INCF   5D,F
0368A:  MOVWF  00
0368C:  MOVWF  x99
0368E:  CALL   0EA0
03692:  MOVLW  14
03694:  SUBWF  5D,W
03696:  BNZ   3682
....................             delay_ms(1300); 
03698:  MOVLW  0A
0369A:  MOVWF  5D
0369C:  MOVLW  82
0369E:  MOVWF  x9A
036A0:  CALL   0C22
036A4:  DECFSZ 5D,F
036A6:  BRA    369C
....................             while(Rob.CompleteSpec == FALSE)  //-- Wait For JudgeMent Spec To Complete 
....................                { 
036A8:  BTFSC  19.2
036AA:  BRA    36B6
....................                   Rob.CompleteSpec = Setting_SpecScrew();  
036AC:  BRA    3416
036AE:  BCF    19.2
036B0:  BTFSC  01.0
036B2:  BSF    19.2
....................                }     
036B4:  BRA    36A8
....................                 
....................       delay_ms(1200); 
036B6:  MOVLW  05
036B8:  MOVWF  5D
036BA:  MOVLW  F0
036BC:  MOVWF  x9A
036BE:  CALL   0C22
036C2:  DECFSZ 5D,F
036C4:  BRA    36BA
....................       Rob.Reset_Flag   = TRUE; 
036C6:  BSF    19.0
....................       Rob.CompleteSpec = FALSE;  
036C8:  BCF    19.2
.................... } 
036CA:  GOTO   4336 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SETTING TYPE FOR CHECKING SCREW 
.................... boolean Setting_SpecScrew(void) 
.................... { 
....................   boolean ret = FALSE; 
*
03416:  BCF    5D.0
....................    
....................       sw = GetStatus_SS(SW_ID); 
03418:  MOVLW  70
0341A:  MOVWF  5E
0341C:  CALL   10AC
03420:  MOVFF  01,2A
....................       if(sw == 0xF7)                      //--------------- Choose Mode Check 
03424:  MOVF   2A,W
03426:  SUBLW  F7
03428:  BNZ   34BA
....................          { 
....................             delay_ms(100); 
0342A:  MOVLW  64
0342C:  MOVWF  x9A
0342E:  CALL   0C22
....................             while(sw == 0xF7) { sw = GetStatus_SS(SW_ID); }  
03432:  MOVF   2A,W
03434:  SUBLW  F7
03436:  BNZ   3446
03438:  MOVLW  70
0343A:  MOVWF  5E
0343C:  CALL   10AC
03440:  MOVFF  01,2A
03444:  BRA    3432
....................             SPEC.TypeScr = 1; 
03446:  MOVLW  01
03448:  MOVWF  29
....................             ret = FALSE; 
0344A:  BCF    5D.0
....................             lcd_gotoxy(1,2); printf(lcd_putc,">> Check all screw  "); 
0344C:  MOVWF  x9A
0344E:  MOVLW  02
03450:  MOVWF  x9B
03452:  CALL   0E36
03456:  CLRF   5E
03458:  MOVF   5E,W
0345A:  CALL   067C
0345E:  INCF   5E,F
03460:  MOVWF  00
03462:  MOVWF  x99
03464:  CALL   0EA0
03468:  MOVLW  14
0346A:  SUBWF  5E,W
0346C:  BNZ   3458
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   Don't care all   "); 
0346E:  MOVLW  01
03470:  MOVWF  x9A
03472:  MOVLW  03
03474:  MOVWF  x9B
03476:  CALL   0E36
0347A:  CLRF   5E
0347C:  MOVF   5E,W
0347E:  CALL   06B0
03482:  INCF   5E,F
03484:  MOVWF  00
03486:  MOVWF  x99
03488:  CALL   0EA0
0348C:  MOVLW  14
0348E:  SUBWF  5E,W
03490:  BNZ   347C
....................             lcd_gotoxy(1,4); printf(lcd_putc,"                    ");  
03492:  MOVLW  01
03494:  MOVWF  x9A
03496:  MOVLW  04
03498:  MOVWF  x9B
0349A:  CALL   0E36
0349E:  CLRF   5E
034A0:  MOVF   5E,W
034A2:  CALL   01EE
034A6:  INCF   5E,F
034A8:  MOVWF  00
034AA:  MOVWF  x99
034AC:  CALL   0EA0
034B0:  MOVLW  14
034B2:  SUBWF  5E,W
034B4:  BNZ   34A0
....................             Buzzer_Beep(); 
034B6:  RCALL  3208
....................          } 
....................           
....................       else if(sw == 0xEF)                //---------------  Choose Mode Interface 
034B8:  BRA    357E
034BA:  MOVF   2A,W
034BC:  SUBLW  EF
034BE:  BNZ   3552
....................          { 
....................             delay_ms(100); 
034C0:  MOVLW  64
034C2:  MOVWF  x9A
034C4:  CALL   0C22
....................             while(sw == 0xEF) { sw = GetStatus_SS(SW_ID); }  
034C8:  MOVF   2A,W
034CA:  SUBLW  EF
034CC:  BNZ   34DC
034CE:  MOVLW  70
034D0:  MOVWF  5E
034D2:  CALL   10AC
034D6:  MOVFF  01,2A
034DA:  BRA    34C8
....................             SPEC.TypeScr = 2; 
034DC:  MOVLW  02
034DE:  MOVWF  29
....................             ret = FALSE; 
034E0:  BCF    5D.0
....................             lcd_gotoxy(1,2); printf(lcd_putc,"   Check all screw  "); 
034E2:  MOVLW  01
034E4:  MOVWF  x9A
034E6:  MOVLW  02
034E8:  MOVWF  x9B
034EA:  CALL   0E36
034EE:  CLRF   5E
034F0:  MOVF   5E,W
034F2:  CALL   06E4
034F6:  INCF   5E,F
034F8:  MOVWF  00
034FA:  MOVWF  x99
034FC:  CALL   0EA0
03500:  MOVLW  14
03502:  SUBWF  5E,W
03504:  BNZ   34F0
....................             lcd_gotoxy(1,3); printf(lcd_putc,">> Don't care all   "); 
03506:  MOVLW  01
03508:  MOVWF  x9A
0350A:  MOVLW  03
0350C:  MOVWF  x9B
0350E:  CALL   0E36
03512:  CLRF   5E
03514:  MOVF   5E,W
03516:  CALL   0718
0351A:  INCF   5E,F
0351C:  MOVWF  00
0351E:  MOVWF  x99
03520:  CALL   0EA0
03524:  MOVLW  14
03526:  SUBWF  5E,W
03528:  BNZ   3514
....................             lcd_gotoxy(1,4); printf(lcd_putc,"                    ");  
0352A:  MOVLW  01
0352C:  MOVWF  x9A
0352E:  MOVLW  04
03530:  MOVWF  x9B
03532:  CALL   0E36
03536:  CLRF   5E
03538:  MOVF   5E,W
0353A:  CALL   01EE
0353E:  INCF   5E,F
03540:  MOVWF  00
03542:  MOVWF  x99
03544:  CALL   0EA0
03548:  MOVLW  14
0354A:  SUBWF  5E,W
0354C:  BNZ   3538
....................             Buzzer_Beep(); 
0354E:  RCALL  3208
....................          }  
....................           
....................           
....................      else if(sw == 0x7F) //---------------  Choose Mode Interface 
03550:  BRA    357E
03552:  MOVF   2A,W
03554:  SUBLW  7F
03556:  BNZ   357E
....................          { 
....................             delay_ms(100); 
03558:  MOVLW  64
0355A:  MOVWF  x9A
0355C:  CALL   0C22
....................             while(sw == 0x7F) { sw = GetStatus_SS(SW_ID); } 
03560:  MOVF   2A,W
03562:  SUBLW  7F
03564:  BNZ   3574
03566:  MOVLW  70
03568:  MOVWF  5E
0356A:  CALL   10AC
0356E:  MOVFF  01,2A
03572:  BRA    3560
....................             ret = TRUE; 
03574:  BSF    5D.0
....................             Buzzer_Config(); 
03576:  RCALL  321E
....................             Save_TypeScrew(SPEC.TypeScr); 
03578:  MOVFF  29,5E
0357C:  BRA    3270
....................          } 
....................           
....................   return(ret); 
0357E:  MOVLW  00
03580:  BTFSC  5D.0
03582:  MOVLW  01
03584:  MOVWF  01
.................... } 
03586:  GOTO   36AE (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SAVE TYPE FOR CHECK SCREW TO EEPROM 
.................... void Save_TypeScrew(byte TypeChk) 
.................... { 
....................    lcd_gotoxy(1,1); printf(lcd_putc,"Save type check...  "); 
*
03270:  MOVLW  01
03272:  MOVWF  x9A
03274:  MOVWF  x9B
03276:  CALL   0E36
0327A:  CLRF   5F
0327C:  MOVF   5F,W
0327E:  CALL   074C
03282:  INCF   5F,F
03284:  MOVWF  00
03286:  MOVWF  x99
03288:  CALL   0EA0
0328C:  MOVLW  14
0328E:  SUBWF  5F,W
03290:  BNZ   327C
....................    lcd_gotoxy(1,3); printf(lcd_putc,"                    "); 
03292:  MOVLW  01
03294:  MOVWF  x9A
03296:  MOVLW  03
03298:  MOVWF  x9B
0329A:  CALL   0E36
0329E:  CLRF   5F
032A0:  MOVF   5F,W
032A2:  CALL   01EE
032A6:  INCF   5F,F
032A8:  MOVWF  00
032AA:  MOVWF  x99
032AC:  CALL   0EA0
032B0:  MOVLW  14
032B2:  SUBWF  5F,W
032B4:  BNZ   32A0
....................    lcd_gotoxy(1,4); printf(lcd_putc,"                    "); 
032B6:  MOVLW  01
032B8:  MOVWF  x9A
032BA:  MOVLW  04
032BC:  MOVWF  x9B
032BE:  CALL   0E36
032C2:  CLRF   5F
032C4:  MOVF   5F,W
032C6:  CALL   01EE
032CA:  INCF   5F,F
032CC:  MOVWF  00
032CE:  MOVWF  x99
032D0:  CALL   0EA0
032D4:  MOVLW  14
032D6:  SUBWF  5F,W
032D8:  BNZ   32C4
....................    delay_ms(100); 
032DA:  MOVLW  64
032DC:  MOVWF  x9A
032DE:  CALL   0C22
....................     
....................    switch(TypeChk) 
....................    { 
032E2:  MOVF   5E,W
032E4:  XORLW  01
032E6:  BZ    32EE
032E8:  XORLW  03
032EA:  BZ    334A
032EC:  BRA    33A6
....................       case 1:   
....................                write_eeprom(70,1);   delay_ms(1); 
032EE:  CLRF   FAA
032F0:  MOVLW  46
032F2:  MOVWF  FA9
032F4:  MOVLW  01
032F6:  MOVWF  FA8
032F8:  BCF    FA6.6
032FA:  BCF    FA6.7
032FC:  BSF    FA6.2
032FE:  MOVFF  FF2,00
03302:  BCF    FF2.7
03304:  MOVLB  F
03306:  MOVLW  55
03308:  MOVWF  FA7
0330A:  MOVLW  AA
0330C:  MOVWF  FA7
0330E:  BSF    FA6.1
03310:  BTFSC  FA6.1
03312:  BRA    3310
03314:  BCF    FA6.2
03316:  MOVF   00,W
03318:  IORWF  FF2,F
0331A:  MOVLW  01
0331C:  MOVLB  0
0331E:  MOVWF  x9A
03320:  CALL   0C22
....................                lcd_gotoxy(1,2); printf(lcd_putc,"Use mode check all  "); 
03324:  MOVLW  01
03326:  MOVWF  x9A
03328:  MOVLW  02
0332A:  MOVWF  x9B
0332C:  CALL   0E36
03330:  CLRF   5F
03332:  MOVF   5F,W
03334:  CALL   0780
03338:  INCF   5F,F
0333A:  MOVWF  00
0333C:  MOVWF  x99
0333E:  CALL   0EA0
03342:  MOVLW  14
03344:  SUBWF  5F,W
03346:  BNZ   3332
....................       break; 
03348:  BRA    3402
....................        
....................       case 2:   
....................                write_eeprom(70,2);   delay_ms(1); 
0334A:  CLRF   FAA
0334C:  MOVLW  46
0334E:  MOVWF  FA9
03350:  MOVLW  02
03352:  MOVWF  FA8
03354:  BCF    FA6.6
03356:  BCF    FA6.7
03358:  BSF    FA6.2
0335A:  MOVFF  FF2,00
0335E:  BCF    FF2.7
03360:  MOVLB  F
03362:  MOVLW  55
03364:  MOVWF  FA7
03366:  MOVLW  AA
03368:  MOVWF  FA7
0336A:  BSF    FA6.1
0336C:  BTFSC  FA6.1
0336E:  BRA    336C
03370:  BCF    FA6.2
03372:  MOVF   00,W
03374:  IORWF  FF2,F
03376:  MOVLW  01
03378:  MOVLB  0
0337A:  MOVWF  x9A
0337C:  CALL   0C22
....................                lcd_gotoxy(1,2); printf(lcd_putc,"Use mode Don't Care "); 
03380:  MOVLW  01
03382:  MOVWF  x9A
03384:  MOVLW  02
03386:  MOVWF  x9B
03388:  CALL   0E36
0338C:  CLRF   5F
0338E:  MOVF   5F,W
03390:  CALL   07B4
03394:  INCF   5F,F
03396:  MOVWF  00
03398:  MOVWF  x99
0339A:  CALL   0EA0
0339E:  MOVLW  14
033A0:  SUBWF  5F,W
033A2:  BNZ   338E
....................       break; 
033A4:  BRA    3402
....................        
....................       default:  
....................                write_eeprom(70,1);   delay_ms(1); 
033A6:  CLRF   FAA
033A8:  MOVLW  46
033AA:  MOVWF  FA9
033AC:  MOVLW  01
033AE:  MOVWF  FA8
033B0:  BCF    FA6.6
033B2:  BCF    FA6.7
033B4:  BSF    FA6.2
033B6:  MOVFF  FF2,00
033BA:  BCF    FF2.7
033BC:  MOVLB  F
033BE:  MOVLW  55
033C0:  MOVWF  FA7
033C2:  MOVLW  AA
033C4:  MOVWF  FA7
033C6:  BSF    FA6.1
033C8:  BTFSC  FA6.1
033CA:  BRA    33C8
033CC:  BCF    FA6.2
033CE:  MOVF   00,W
033D0:  IORWF  FF2,F
033D2:  MOVLW  01
033D4:  MOVLB  0
033D6:  MOVWF  x9A
033D8:  CALL   0C22
....................                lcd_gotoxy(1,2); printf(lcd_putc,"Use mode check all  "); 
033DC:  MOVLW  01
033DE:  MOVWF  x9A
033E0:  MOVLW  02
033E2:  MOVWF  x9B
033E4:  CALL   0E36
033E8:  CLRF   5F
033EA:  MOVF   5F,W
033EC:  CALL   0780
033F0:  INCF   5F,F
033F2:  MOVWF  00
033F4:  MOVWF  x99
033F6:  CALL   0EA0
033FA:  MOVLW  14
033FC:  SUBWF  5F,W
033FE:  BNZ   33EA
....................       break; 
03400:  BRA    3402
....................    } 
....................     
....................    delay_ms(2000); 
03402:  MOVLW  08
03404:  MOVWF  5F
03406:  MOVLW  FA
03408:  MOVWF  x9A
0340A:  CALL   0C22
0340E:  DECFSZ 5F,F
03410:  BRA    3406
....................        
.................... } 
03412:  GOTO   357E (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   READ TYPE OF MODE CHECK SCREW FROM EEPROM 
.................... void Read_TypeScrew(void) 
.................... {    
....................    SPEC.TypeScr = read_eeprom(70); 
*
00F64:  MOVFF  FF2,5D
00F68:  BCF    FF2.7
00F6A:  CLRF   FAA
00F6C:  MOVLW  46
00F6E:  MOVWF  FA9
00F70:  BCF    FA6.6
00F72:  BCF    FA6.7
00F74:  BSF    FA6.0
00F76:  MOVF   FA8,W
00F78:  BTFSC  5D.7
00F7A:  BSF    FF2.7
00F7C:  MOVWF  29
....................    delay_ms(250); 
00F7E:  MOVLW  FA
00F80:  MOVWF  x9A
00F82:  RCALL  0C22
....................     
....................      switch(SPEC.TypeScr) 
....................             { 
00F84:  MOVF   29,W
00F86:  XORLW  01
00F88:  BZ    0F90
00F8A:  XORLW  03
00F8C:  BZ    0FB0
00F8E:  BRA    0FD0
....................                case 1: //----------- READ MODE CHECK ALL SCREW 
....................                        lcd_gotoxy(1,2); printf(lcd_putc,"Check all screw     "); 
00F90:  MOVLW  01
00F92:  MOVWF  x9A
00F94:  MOVLW  02
00F96:  MOVWF  x9B
00F98:  RCALL  0E36
00F9A:  CLRF   5D
00F9C:  MOVF   5D,W
00F9E:  RCALL  07E8
00FA0:  INCF   5D,F
00FA2:  MOVWF  00
00FA4:  MOVWF  x99
00FA6:  RCALL  0EA0
00FA8:  MOVLW  14
00FAA:  SUBWF  5D,W
00FAC:  BNZ   0F9C
....................                break; 
00FAE:  BRA    0FF0
....................                 
....................                case 2: //----------- READ MODE DON'T CARE FOR CHECK ALL SCREW 
....................                        lcd_gotoxy(1,2); printf(lcd_putc,"Don't care all screw"); 
00FB0:  MOVLW  01
00FB2:  MOVWF  x9A
00FB4:  MOVLW  02
00FB6:  MOVWF  x9B
00FB8:  RCALL  0E36
00FBA:  CLRF   5D
00FBC:  MOVF   5D,W
00FBE:  RCALL  081C
00FC0:  INCF   5D,F
00FC2:  MOVWF  00
00FC4:  MOVWF  x99
00FC6:  RCALL  0EA0
00FC8:  MOVLW  14
00FCA:  SUBWF  5D,W
00FCC:  BNZ   0FBC
....................                break; 
00FCE:  BRA    0FF0
....................                 
....................                default: 
....................                        lcd_gotoxy(1,2); printf(lcd_putc,"Check all screw     "); 
00FD0:  MOVLW  01
00FD2:  MOVWF  x9A
00FD4:  MOVLW  02
00FD6:  MOVWF  x9B
00FD8:  RCALL  0E36
00FDA:  CLRF   5D
00FDC:  MOVF   5D,W
00FDE:  RCALL  07E8
00FE0:  INCF   5D,F
00FE2:  MOVWF  00
00FE4:  MOVWF  x99
00FE6:  RCALL  0EA0
00FE8:  MOVLW  14
00FEA:  SUBWF  5D,W
00FEC:  BNZ   0FDC
....................                break; 
00FEE:  BRA    0FF0
....................             } 
....................         
.................... } 
00FF0:  GOTO   13D4 (RETURN)
....................  
....................  
....................  
....................  
.................... //##############################################################################------------(4) 
.................... //                     PART JUDGEMENT COILS RESISTANCE  
.................... //############################################################################## 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   JUDGEMENT SPEC OF COILS RESISTANCE 
.................... void Setting_Coils(void)  
.................... { 
....................       Rob.Reset_Flag   = FALSE; 
*
03DEE:  BCF    19.0
....................       Rob.CompleteSpec = FALSE; 
03DF0:  BCF    19.2
....................  
....................             lcd_gotoxy(1,1); printf(lcd_putc,"Config Spec Coils.. "); 
03DF2:  MOVLW  01
03DF4:  MOVWF  x9A
03DF6:  MOVWF  x9B
03DF8:  CALL   0E36
03DFC:  CLRF   5D
03DFE:  MOVF   5D,W
03E00:  CALL   0850
03E04:  INCF   5D,F
03E06:  MOVWF  00
03E08:  MOVWF  x99
03E0A:  CALL   0EA0
03E0E:  MOVLW  14
03E10:  SUBWF  5D,W
03E12:  BNZ   3DFE
....................             delay_ms(100); 
03E14:  MOVLW  64
03E16:  MOVWF  x9A
03E18:  CALL   0C22
....................             lcd_gotoxy(1,2); printf(lcd_putc,"C1H: %03ld  C1L: %03ld  ",SPEC.C1h,SPEC.C1l); 
03E1C:  MOVLW  01
03E1E:  MOVWF  x9A
03E20:  MOVLW  02
03E22:  MOVWF  x9B
03E24:  CALL   0E36
03E28:  CLRF   5D
03E2A:  MOVF   5D,W
03E2C:  CALL   0884
03E30:  INCF   5D,F
03E32:  MOVWF  00
03E34:  MOVWF  x99
03E36:  CALL   0EA0
03E3A:  MOVLW  05
03E3C:  SUBWF  5D,W
03E3E:  BNZ   3E2A
03E40:  MOVLW  0B
03E42:  MOVWF  FE9
03E44:  MOVFF  1D,60
03E48:  MOVFF  1C,5F
03E4C:  CALL   10F6
03E50:  MOVLW  0A
03E52:  MOVWF  5E
03E54:  MOVF   5E,W
03E56:  CALL   0884
03E5A:  INCF   5E,F
03E5C:  MOVWF  00
03E5E:  MOVWF  x99
03E60:  CALL   0EA0
03E64:  MOVLW  11
03E66:  SUBWF  5E,W
03E68:  BNZ   3E54
03E6A:  MOVLW  0B
03E6C:  MOVWF  FE9
03E6E:  MOVFF  1F,60
03E72:  MOVFF  1E,5F
03E76:  CALL   10F6
03E7A:  MOVLW  20
03E7C:  MOVWF  x99
03E7E:  CALL   0EA0
03E82:  MOVLW  20
03E84:  MOVWF  x99
03E86:  CALL   0EA0
....................             lcd_gotoxy(1,3); printf(lcd_putc,"C2H: %03ld  C2L: %03ld  ",SPEC.C2h,SPEC.C2l); 
03E8A:  MOVLW  01
03E8C:  MOVWF  x9A
03E8E:  MOVLW  03
03E90:  MOVWF  x9B
03E92:  CALL   0E36
03E96:  CLRF   5D
03E98:  MOVF   5D,W
03E9A:  CALL   08BC
03E9E:  INCF   5D,F
03EA0:  MOVWF  00
03EA2:  MOVWF  x99
03EA4:  CALL   0EA0
03EA8:  MOVLW  05
03EAA:  SUBWF  5D,W
03EAC:  BNZ   3E98
03EAE:  MOVLW  0B
03EB0:  MOVWF  FE9
03EB2:  MOVFF  21,60
03EB6:  MOVFF  20,5F
03EBA:  CALL   10F6
03EBE:  MOVLW  0A
03EC0:  MOVWF  5E
03EC2:  MOVF   5E,W
03EC4:  CALL   08BC
03EC8:  INCF   5E,F
03ECA:  MOVWF  00
03ECC:  MOVWF  x99
03ECE:  CALL   0EA0
03ED2:  MOVLW  11
03ED4:  SUBWF  5E,W
03ED6:  BNZ   3EC2
03ED8:  MOVLW  0B
03EDA:  MOVWF  FE9
03EDC:  MOVFF  23,60
03EE0:  MOVFF  22,5F
03EE4:  CALL   10F6
03EE8:  MOVLW  20
03EEA:  MOVWF  x99
03EEC:  CALL   0EA0
03EF0:  MOVLW  20
03EF2:  MOVWF  x99
03EF4:  CALL   0EA0
....................             lcd_gotoxy(1,4); printf(lcd_putc,"C3H: %03ld  C3L: %03ld  ",SPEC.C3h,SPEC.C3l); 
03EF8:  MOVLW  01
03EFA:  MOVWF  x9A
03EFC:  MOVLW  04
03EFE:  MOVWF  x9B
03F00:  CALL   0E36
03F04:  CLRF   5D
03F06:  MOVF   5D,W
03F08:  CALL   08F4
03F0C:  INCF   5D,F
03F0E:  MOVWF  00
03F10:  MOVWF  x99
03F12:  CALL   0EA0
03F16:  MOVLW  05
03F18:  SUBWF  5D,W
03F1A:  BNZ   3F06
03F1C:  MOVLW  0B
03F1E:  MOVWF  FE9
03F20:  MOVFF  25,60
03F24:  MOVFF  24,5F
03F28:  CALL   10F6
03F2C:  MOVLW  0A
03F2E:  MOVWF  5E
03F30:  MOVF   5E,W
03F32:  CALL   08F4
03F36:  INCF   5E,F
03F38:  MOVWF  00
03F3A:  MOVWF  x99
03F3C:  CALL   0EA0
03F40:  MOVLW  11
03F42:  SUBWF  5E,W
03F44:  BNZ   3F30
03F46:  MOVLW  0B
03F48:  MOVWF  FE9
03F4A:  MOVFF  27,60
03F4E:  MOVFF  26,5F
03F52:  CALL   10F6
03F56:  MOVLW  20
03F58:  MOVWF  x99
03F5A:  CALL   0EA0
03F5E:  MOVLW  20
03F60:  MOVWF  x99
03F62:  CALL   0EA0
....................             delay_ms(1300); 
03F66:  MOVLW  0A
03F68:  MOVWF  5D
03F6A:  MOVLW  82
03F6C:  MOVWF  x9A
03F6E:  CALL   0C22
03F72:  DECFSZ 5D,F
03F74:  BRA    3F6A
....................             while(Rob.CompleteSpec == FALSE)        //-- Wait For JudgeMent Spec To Complete 
....................                { 
03F76:  BTFSC  19.2
03F78:  BRA    3F84
....................                   Rob.CompleteSpec = Setting_SpecCoils();  
03F7A:  BRA    396E
03F7C:  BCF    19.2
03F7E:  BTFSC  01.0
03F80:  BSF    19.2
....................                }   
03F82:  BRA    3F76
....................                 
....................       delay_ms(1500); 
03F84:  MOVLW  06
03F86:  MOVWF  5D
03F88:  MOVLW  FA
03F8A:  MOVWF  x9A
03F8C:  CALL   0C22
03F90:  DECFSZ 5D,F
03F92:  BRA    3F88
....................       Rob.Reset_Flag   = TRUE; 
03F94:  BSF    19.0
....................       Rob.CompleteSpec = FALSE;               
03F96:  BCF    19.2
.................... } 
03F98:  GOTO   4336 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SETTING SPEC OF COIL RESISTANCE 
.................... boolean Setting_SpecCoils(void) 
.................... { 
....................   boolean ret = FALSE; 
*
0396E:  BCF    5D.0
....................     
....................       sw = GetStatus_SS(SW_ID); 
03970:  MOVLW  70
03972:  MOVWF  5E
03974:  CALL   10AC
03978:  MOVFF  01,2A
.................... //------------------   Judgement Value of The First Coil   --------------------- 
....................       if(sw == 0xF7)       //--------------- Count Up High Spec of The First Coil 
0397C:  MOVF   2A,W
0397E:  SUBLW  F7
03980:  BNZ   39D4
....................          { 
....................             delay_ms(100); 
03982:  MOVLW  64
03984:  MOVWF  x9A
03986:  CALL   0C22
....................             while(sw == 0xF7) { sw = GetStatus_SS(SW_ID); } 
0398A:  MOVF   2A,W
0398C:  SUBLW  F7
0398E:  BNZ   399E
03990:  MOVLW  70
03992:  MOVWF  5E
03994:  CALL   10AC
03998:  MOVFF  01,2A
0399C:  BRA    398A
....................             Buzzer_Beep(); 
0399E:  RCALL  3208
....................                        
....................             if(SPEC.C1h >= 255) SPEC.C1h = 0; 
039A0:  MOVF   1D,F
039A2:  BNZ   39AA
039A4:  MOVF   1C,W
039A6:  SUBLW  FE
039A8:  BC    39AE
039AA:  CLRF   1D
039AC:  CLRF   1C
....................             SPEC.C1h++; 
039AE:  INCF   1C,F
039B0:  BTFSC  FD8.2
039B2:  INCF   1D,F
....................             lcd_gotoxy(6,2); printf(lcd_putc,"%03ld",SPEC.C1h); 
039B4:  MOVLW  06
039B6:  MOVWF  x9A
039B8:  MOVLW  02
039BA:  MOVWF  x9B
039BC:  CALL   0E36
039C0:  MOVLW  0B
039C2:  MOVWF  FE9
039C4:  MOVFF  1D,60
039C8:  MOVFF  1C,5F
039CC:  CALL   10F6
....................             ret = FALSE; 
039D0:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xEF)   //--------------- Count Down High Spec of The First Coil 
039D2:  BRA    3AE2
039D4:  MOVF   2A,W
039D6:  SUBLW  EF
039D8:  BNZ   3A2E
....................          { 
....................             delay_ms(100); 
039DA:  MOVLW  64
039DC:  MOVWF  x9A
039DE:  CALL   0C22
....................             while(sw == 0xEF) { sw = GetStatus_SS(SW_ID); } 
039E2:  MOVF   2A,W
039E4:  SUBLW  EF
039E6:  BNZ   39F6
039E8:  MOVLW  70
039EA:  MOVWF  5E
039EC:  CALL   10AC
039F0:  MOVFF  01,2A
039F4:  BRA    39E2
....................             Buzzer_Beep(); 
039F6:  RCALL  3208
....................             
....................             if(SPEC.C1h < 1) SPEC.C1h = 256; 
039F8:  MOVF   1C,F
039FA:  BNZ   3A06
039FC:  MOVF   1D,F
039FE:  BNZ   3A06
03A00:  MOVLW  01
03A02:  MOVWF  1D
03A04:  CLRF   1C
....................             SPEC.C1h--; 
03A06:  MOVF   1C,W
03A08:  BTFSC  FD8.2
03A0A:  DECF   1D,F
03A0C:  DECF   1C,F
....................             lcd_gotoxy(6,2); printf(lcd_putc,"%03ld",SPEC.C1h); 
03A0E:  MOVLW  06
03A10:  MOVWF  x9A
03A12:  MOVLW  02
03A14:  MOVWF  x9B
03A16:  CALL   0E36
03A1A:  MOVLW  0B
03A1C:  MOVWF  FE9
03A1E:  MOVFF  1D,60
03A22:  MOVFF  1C,5F
03A26:  CALL   10F6
....................             ret = FALSE; 
03A2A:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xF3)   //--------------- Count Up Low Spec of The First Coil 
03A2C:  BRA    3AE2
03A2E:  MOVF   2A,W
03A30:  SUBLW  F3
03A32:  BNZ   3A88
....................          { 
....................             delay_ms(100); 
03A34:  MOVLW  64
03A36:  MOVWF  x9A
03A38:  CALL   0C22
....................             while(sw == 0xF3) { sw = GetStatus_SS(SW_ID); } 
03A3C:  MOVF   2A,W
03A3E:  SUBLW  F3
03A40:  BNZ   3A50
03A42:  MOVLW  70
03A44:  MOVWF  5E
03A46:  CALL   10AC
03A4A:  MOVFF  01,2A
03A4E:  BRA    3A3C
....................             Buzzer_Beep(); 
03A50:  CALL   3208
....................          
....................             if(SPEC.C1l >= 255) SPEC.C1l = 0; 
03A54:  MOVF   1F,F
03A56:  BNZ   3A5E
03A58:  MOVF   1E,W
03A5A:  SUBLW  FE
03A5C:  BC    3A62
03A5E:  CLRF   1F
03A60:  CLRF   1E
....................             SPEC.C1l++; 
03A62:  INCF   1E,F
03A64:  BTFSC  FD8.2
03A66:  INCF   1F,F
....................             lcd_gotoxy(16,2); printf(lcd_putc,"%03ld",SPEC.C1l); 
03A68:  MOVLW  10
03A6A:  MOVWF  x9A
03A6C:  MOVLW  02
03A6E:  MOVWF  x9B
03A70:  CALL   0E36
03A74:  MOVLW  0B
03A76:  MOVWF  FE9
03A78:  MOVFF  1F,60
03A7C:  MOVFF  1E,5F
03A80:  CALL   10F6
....................             ret = FALSE; 
03A84:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xEB)   //--------------- Count Down Low Spec of The First Coil 
03A86:  BRA    3AE2
03A88:  MOVF   2A,W
03A8A:  SUBLW  EB
03A8C:  BNZ   3AE2
....................          { 
....................             delay_ms(100); 
03A8E:  MOVLW  64
03A90:  MOVWF  x9A
03A92:  CALL   0C22
....................             while(sw == 0xEB) { sw = GetStatus_SS(SW_ID); } 
03A96:  MOVF   2A,W
03A98:  SUBLW  EB
03A9A:  BNZ   3AAA
03A9C:  MOVLW  70
03A9E:  MOVWF  5E
03AA0:  CALL   10AC
03AA4:  MOVFF  01,2A
03AA8:  BRA    3A96
....................             Buzzer_Beep(); 
03AAA:  CALL   3208
....................            
....................             if(SPEC.C1l < 1) SPEC.C1l = 256; 
03AAE:  MOVF   1E,F
03AB0:  BNZ   3ABC
03AB2:  MOVF   1F,F
03AB4:  BNZ   3ABC
03AB6:  MOVLW  01
03AB8:  MOVWF  1F
03ABA:  CLRF   1E
....................             SPEC.C1l--; 
03ABC:  MOVF   1E,W
03ABE:  BTFSC  FD8.2
03AC0:  DECF   1F,F
03AC2:  DECF   1E,F
....................             lcd_gotoxy(16,2); printf(lcd_putc,"%03ld",SPEC.C1l); 
03AC4:  MOVLW  10
03AC6:  MOVWF  x9A
03AC8:  MOVLW  02
03ACA:  MOVWF  x9B
03ACC:  CALL   0E36
03AD0:  MOVLW  0B
03AD2:  MOVWF  FE9
03AD4:  MOVFF  1F,60
03AD8:  MOVFF  1E,5F
03ADC:  CALL   10F6
....................             ret = FALSE; 
03AE0:  BCF    5D.0
....................          } 
....................           
.................... //------------------   Judgement Value of The Second Coil   -------------------- 
....................       if(sw == 0xF5)       //--------------- Count Up High Spec of The Second Coil 
03AE2:  MOVF   2A,W
03AE4:  SUBLW  F5
03AE6:  BNZ   3B3C
....................          { 
....................             delay_ms(100); 
03AE8:  MOVLW  64
03AEA:  MOVWF  x9A
03AEC:  CALL   0C22
....................             while(sw == 0xF5) { sw = GetStatus_SS(SW_ID); } 
03AF0:  MOVF   2A,W
03AF2:  SUBLW  F5
03AF4:  BNZ   3B04
03AF6:  MOVLW  70
03AF8:  MOVWF  5E
03AFA:  CALL   10AC
03AFE:  MOVFF  01,2A
03B02:  BRA    3AF0
....................             Buzzer_Beep(); 
03B04:  CALL   3208
....................           
....................             if(SPEC.C2h >= 255) SPEC.C2h = 0; 
03B08:  MOVF   21,F
03B0A:  BNZ   3B12
03B0C:  MOVF   20,W
03B0E:  SUBLW  FE
03B10:  BC    3B16
03B12:  CLRF   21
03B14:  CLRF   20
....................             SPEC.C2h++; 
03B16:  INCF   20,F
03B18:  BTFSC  FD8.2
03B1A:  INCF   21,F
....................             lcd_gotoxy(6,3); printf(lcd_putc,"%03ld",SPEC.C2h); 
03B1C:  MOVLW  06
03B1E:  MOVWF  x9A
03B20:  MOVLW  03
03B22:  MOVWF  x9B
03B24:  CALL   0E36
03B28:  MOVLW  0B
03B2A:  MOVWF  FE9
03B2C:  MOVFF  21,60
03B30:  MOVFF  20,5F
03B34:  CALL   10F6
....................             ret = FALSE; 
03B38:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xED)   //--------------- Count Down High Spec of The Second Coil 
03B3A:  BRA    3C4C
03B3C:  MOVF   2A,W
03B3E:  SUBLW  ED
03B40:  BNZ   3B98
....................          { 
....................             delay_ms(100); 
03B42:  MOVLW  64
03B44:  MOVWF  x9A
03B46:  CALL   0C22
....................             while(sw == 0xED) { sw = GetStatus_SS(SW_ID); } 
03B4A:  MOVF   2A,W
03B4C:  SUBLW  ED
03B4E:  BNZ   3B5E
03B50:  MOVLW  70
03B52:  MOVWF  5E
03B54:  CALL   10AC
03B58:  MOVFF  01,2A
03B5C:  BRA    3B4A
....................             Buzzer_Beep(); 
03B5E:  CALL   3208
....................            
....................             if(SPEC.C2h < 1) SPEC.C2h = 256; 
03B62:  MOVF   20,F
03B64:  BNZ   3B70
03B66:  MOVF   21,F
03B68:  BNZ   3B70
03B6A:  MOVLW  01
03B6C:  MOVWF  21
03B6E:  CLRF   20
....................             SPEC.C2h--; 
03B70:  MOVF   20,W
03B72:  BTFSC  FD8.2
03B74:  DECF   21,F
03B76:  DECF   20,F
....................             lcd_gotoxy(6,3); printf(lcd_putc,"%03ld",SPEC.C2h); 
03B78:  MOVLW  06
03B7A:  MOVWF  x9A
03B7C:  MOVLW  03
03B7E:  MOVWF  x9B
03B80:  CALL   0E36
03B84:  MOVLW  0B
03B86:  MOVWF  FE9
03B88:  MOVFF  21,60
03B8C:  MOVFF  20,5F
03B90:  CALL   10F6
....................             ret = FALSE; 
03B94:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xF1)   //--------------- Count Up Low Spec of The Second Coil 
03B96:  BRA    3C4C
03B98:  MOVF   2A,W
03B9A:  SUBLW  F1
03B9C:  BNZ   3BF2
....................          { 
....................             delay_ms(100); 
03B9E:  MOVLW  64
03BA0:  MOVWF  x9A
03BA2:  CALL   0C22
....................             while(sw == 0xF1) { sw = GetStatus_SS(SW_ID); } 
03BA6:  MOVF   2A,W
03BA8:  SUBLW  F1
03BAA:  BNZ   3BBA
03BAC:  MOVLW  70
03BAE:  MOVWF  5E
03BB0:  CALL   10AC
03BB4:  MOVFF  01,2A
03BB8:  BRA    3BA6
....................             Buzzer_Beep(); 
03BBA:  CALL   3208
....................             
....................             if(SPEC.C2l >= 255) SPEC.C2l = 0; 
03BBE:  MOVF   23,F
03BC0:  BNZ   3BC8
03BC2:  MOVF   22,W
03BC4:  SUBLW  FE
03BC6:  BC    3BCC
03BC8:  CLRF   23
03BCA:  CLRF   22
....................             SPEC.C2l++; 
03BCC:  INCF   22,F
03BCE:  BTFSC  FD8.2
03BD0:  INCF   23,F
....................             lcd_gotoxy(16,3); printf(lcd_putc,"%03ld",SPEC.C2l); 
03BD2:  MOVLW  10
03BD4:  MOVWF  x9A
03BD6:  MOVLW  03
03BD8:  MOVWF  x9B
03BDA:  CALL   0E36
03BDE:  MOVLW  0B
03BE0:  MOVWF  FE9
03BE2:  MOVFF  23,60
03BE6:  MOVFF  22,5F
03BEA:  CALL   10F6
....................             ret = FALSE; 
03BEE:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xE9)   //--------------- Count Down Low Spec of The Second Coil 
03BF0:  BRA    3C4C
03BF2:  MOVF   2A,W
03BF4:  SUBLW  E9
03BF6:  BNZ   3C4C
....................          { 
....................             delay_ms(100); 
03BF8:  MOVLW  64
03BFA:  MOVWF  x9A
03BFC:  CALL   0C22
....................             while(sw == 0xE9) { sw = GetStatus_SS(SW_ID); } 
03C00:  MOVF   2A,W
03C02:  SUBLW  E9
03C04:  BNZ   3C14
03C06:  MOVLW  70
03C08:  MOVWF  5E
03C0A:  CALL   10AC
03C0E:  MOVFF  01,2A
03C12:  BRA    3C00
....................             Buzzer_Beep(); 
03C14:  CALL   3208
....................              
....................             if(SPEC.C2l < 1) SPEC.C2l = 256; 
03C18:  MOVF   22,F
03C1A:  BNZ   3C26
03C1C:  MOVF   23,F
03C1E:  BNZ   3C26
03C20:  MOVLW  01
03C22:  MOVWF  23
03C24:  CLRF   22
....................             SPEC.C2l--; 
03C26:  MOVF   22,W
03C28:  BTFSC  FD8.2
03C2A:  DECF   23,F
03C2C:  DECF   22,F
....................             lcd_gotoxy(16,3); printf(lcd_putc,"%03ld",SPEC.C2l); 
03C2E:  MOVLW  10
03C30:  MOVWF  x9A
03C32:  MOVLW  03
03C34:  MOVWF  x9B
03C36:  CALL   0E36
03C3A:  MOVLW  0B
03C3C:  MOVWF  FE9
03C3E:  MOVFF  23,60
03C42:  MOVFF  22,5F
03C46:  CALL   10F6
....................             ret = FALSE; 
03C4A:  BCF    5D.0
....................          } 
....................           
....................           
.................... //------------------   Judgement Value of The Third Coil   -------------------- 
....................       if(sw == 0xF6)       //--------------- Count Up High Spec of The Second Coil 
03C4C:  MOVF   2A,W
03C4E:  SUBLW  F6
03C50:  BNZ   3CA6
....................          { 
....................             delay_ms(100); 
03C52:  MOVLW  64
03C54:  MOVWF  x9A
03C56:  CALL   0C22
....................             while(sw == 0xF6) { sw = GetStatus_SS(SW_ID); } 
03C5A:  MOVF   2A,W
03C5C:  SUBLW  F6
03C5E:  BNZ   3C6E
03C60:  MOVLW  70
03C62:  MOVWF  5E
03C64:  CALL   10AC
03C68:  MOVFF  01,2A
03C6C:  BRA    3C5A
....................             Buzzer_Beep(); 
03C6E:  CALL   3208
....................           
....................             if(SPEC.C3h >= 255) SPEC.C3h = 0; 
03C72:  MOVF   25,F
03C74:  BNZ   3C7C
03C76:  MOVF   24,W
03C78:  SUBLW  FE
03C7A:  BC    3C80
03C7C:  CLRF   25
03C7E:  CLRF   24
....................             SPEC.C3h++; 
03C80:  INCF   24,F
03C82:  BTFSC  FD8.2
03C84:  INCF   25,F
....................             lcd_gotoxy(6,4); printf(lcd_putc,"%03ld",SPEC.C3h); 
03C86:  MOVLW  06
03C88:  MOVWF  x9A
03C8A:  MOVLW  04
03C8C:  MOVWF  x9B
03C8E:  CALL   0E36
03C92:  MOVLW  0B
03C94:  MOVWF  FE9
03C96:  MOVFF  25,60
03C9A:  MOVFF  24,5F
03C9E:  CALL   10F6
....................             ret = FALSE; 
03CA2:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xEE)   //--------------- Count Down High Spec of The Second Coil 
03CA4:  BRA    3DE2
03CA6:  MOVF   2A,W
03CA8:  SUBLW  EE
03CAA:  BNZ   3D02
....................          { 
....................             delay_ms(100); 
03CAC:  MOVLW  64
03CAE:  MOVWF  x9A
03CB0:  CALL   0C22
....................             while(sw == 0xEE) { sw = GetStatus_SS(SW_ID); } 
03CB4:  MOVF   2A,W
03CB6:  SUBLW  EE
03CB8:  BNZ   3CC8
03CBA:  MOVLW  70
03CBC:  MOVWF  5E
03CBE:  CALL   10AC
03CC2:  MOVFF  01,2A
03CC6:  BRA    3CB4
....................             Buzzer_Beep(); 
03CC8:  CALL   3208
....................            
....................             if(SPEC.C3h < 1) SPEC.C3h = 256; 
03CCC:  MOVF   24,F
03CCE:  BNZ   3CDA
03CD0:  MOVF   25,F
03CD2:  BNZ   3CDA
03CD4:  MOVLW  01
03CD6:  MOVWF  25
03CD8:  CLRF   24
....................             SPEC.C3h--; 
03CDA:  MOVF   24,W
03CDC:  BTFSC  FD8.2
03CDE:  DECF   25,F
03CE0:  DECF   24,F
....................             lcd_gotoxy(6,4); printf(lcd_putc,"%03ld",SPEC.C3h); 
03CE2:  MOVLW  06
03CE4:  MOVWF  x9A
03CE6:  MOVLW  04
03CE8:  MOVWF  x9B
03CEA:  CALL   0E36
03CEE:  MOVLW  0B
03CF0:  MOVWF  FE9
03CF2:  MOVFF  25,60
03CF6:  MOVFF  24,5F
03CFA:  CALL   10F6
....................             ret = FALSE; 
03CFE:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xF2)   //--------------- Count Up Low Spec of The Second Coil 
03D00:  BRA    3DE2
03D02:  MOVF   2A,W
03D04:  SUBLW  F2
03D06:  BNZ   3D5C
....................          { 
....................             delay_ms(100); 
03D08:  MOVLW  64
03D0A:  MOVWF  x9A
03D0C:  CALL   0C22
....................             while(sw == 0xF2) { sw = GetStatus_SS(SW_ID); } 
03D10:  MOVF   2A,W
03D12:  SUBLW  F2
03D14:  BNZ   3D24
03D16:  MOVLW  70
03D18:  MOVWF  5E
03D1A:  CALL   10AC
03D1E:  MOVFF  01,2A
03D22:  BRA    3D10
....................             Buzzer_Beep(); 
03D24:  CALL   3208
....................             
....................             if(SPEC.C3l >= 255) SPEC.C3l = 0; 
03D28:  MOVF   27,F
03D2A:  BNZ   3D32
03D2C:  MOVF   26,W
03D2E:  SUBLW  FE
03D30:  BC    3D36
03D32:  CLRF   27
03D34:  CLRF   26
....................             SPEC.C3l++; 
03D36:  INCF   26,F
03D38:  BTFSC  FD8.2
03D3A:  INCF   27,F
....................             lcd_gotoxy(16,4); printf(lcd_putc,"%03ld",SPEC.C3l); 
03D3C:  MOVLW  10
03D3E:  MOVWF  x9A
03D40:  MOVLW  04
03D42:  MOVWF  x9B
03D44:  CALL   0E36
03D48:  MOVLW  0B
03D4A:  MOVWF  FE9
03D4C:  MOVFF  27,60
03D50:  MOVFF  26,5F
03D54:  CALL   10F6
....................             ret = FALSE; 
03D58:  BCF    5D.0
....................          } 
....................           
....................       else if(sw == 0xEA)   //--------------- Count Down Low Spec of The Second Coil 
03D5A:  BRA    3DE2
03D5C:  MOVF   2A,W
03D5E:  SUBLW  EA
03D60:  BNZ   3DB8
....................          { 
....................             delay_ms(100); 
03D62:  MOVLW  64
03D64:  MOVWF  x9A
03D66:  CALL   0C22
....................             while(sw == 0xEA) { sw = GetStatus_SS(SW_ID); } 
03D6A:  MOVF   2A,W
03D6C:  SUBLW  EA
03D6E:  BNZ   3D7E
03D70:  MOVLW  70
03D72:  MOVWF  5E
03D74:  CALL   10AC
03D78:  MOVFF  01,2A
03D7C:  BRA    3D6A
....................             Buzzer_Beep(); 
03D7E:  CALL   3208
....................              
....................             if(SPEC.C3l < 1) SPEC.C3l = 256; 
03D82:  MOVF   26,F
03D84:  BNZ   3D90
03D86:  MOVF   27,F
03D88:  BNZ   3D90
03D8A:  MOVLW  01
03D8C:  MOVWF  27
03D8E:  CLRF   26
....................             SPEC.C3l--; 
03D90:  MOVF   26,W
03D92:  BTFSC  FD8.2
03D94:  DECF   27,F
03D96:  DECF   26,F
....................             lcd_gotoxy(16,4); printf(lcd_putc,"%03ld",SPEC.C3l); 
03D98:  MOVLW  10
03D9A:  MOVWF  x9A
03D9C:  MOVLW  04
03D9E:  MOVWF  x9B
03DA0:  CALL   0E36
03DA4:  MOVLW  0B
03DA6:  MOVWF  FE9
03DA8:  MOVFF  27,60
03DAC:  MOVFF  26,5F
03DB0:  CALL   10F6
....................             ret = FALSE; 
03DB4:  BCF    5D.0
....................          }          
....................           
....................       else if(sw == 0x7F) //--------------- SAVE SPEC TO PIC'S EEPROM 
03DB6:  BRA    3DE2
03DB8:  MOVF   2A,W
03DBA:  SUBLW  7F
03DBC:  BNZ   3DE2
....................          { 
....................             delay_ms(100); 
03DBE:  MOVLW  64
03DC0:  MOVWF  x9A
03DC2:  CALL   0C22
....................             while(sw == 0x7F) { sw = GetStatus_SS(SW_ID); } 
03DC6:  MOVF   2A,W
03DC8:  SUBLW  7F
03DCA:  BNZ   3DDA
03DCC:  MOVLW  70
03DCE:  MOVWF  5E
03DD0:  CALL   10AC
03DD4:  MOVFF  01,2A
03DD8:  BRA    3DC6
....................             Buzzer_Config(); 
03DDA:  CALL   321E
....................              
....................             Save_SpecCoils(); 
03DDE:  BRA    36CE
....................             ret = TRUE; 
03DE0:  BSF    5D.0
....................          } 
....................  
....................    return(ret); 
03DE2:  MOVLW  00
03DE4:  BTFSC  5D.0
03DE6:  MOVLW  01
03DE8:  MOVWF  01
.................... } 
03DEA:  GOTO   3F7C (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SAVE COILS RESISTANCE TO EEPROM 
.................... void Save_SpecCoils(void) 
.................... { 
....................    byte x,y; 
....................    lcd_gotoxy(1,1); printf(lcd_putc,"  << Save Spec >>   "); 
*
036CE:  MOVLW  01
036D0:  MOVWF  x9A
036D2:  MOVWF  x9B
036D4:  CALL   0E36
036D8:  CLRF   x60
036DA:  MOVF   x60,W
036DC:  CALL   092C
036E0:  INCF   x60,F
036E2:  MOVWF  00
036E4:  MOVWF  x99
036E6:  CALL   0EA0
036EA:  MOVLW  14
036EC:  SUBWF  x60,W
036EE:  BNZ   36DA
....................    lcd_gotoxy(1,2); printf(lcd_putc,"Wait For Save       "); 
036F0:  MOVLW  01
036F2:  MOVWF  x9A
036F4:  MOVLW  02
036F6:  MOVWF  x9B
036F8:  CALL   0E36
036FC:  CLRF   x60
036FE:  MOVF   x60,W
03700:  CALL   0960
03704:  INCF   x60,F
03706:  MOVWF  00
03708:  MOVWF  x99
0370A:  CALL   0EA0
0370E:  MOVLW  14
03710:  SUBWF  x60,W
03712:  BNZ   36FE
....................    lcd_gotoxy(1,3); printf(lcd_putc,"                  "); 
03714:  MOVLW  01
03716:  MOVWF  x9A
03718:  MOVLW  03
0371A:  MOVWF  x9B
0371C:  CALL   0E36
03720:  CLRF   x60
03722:  MOVF   x60,W
03724:  CALL   0994
03728:  INCF   x60,F
0372A:  MOVWF  00
0372C:  MOVWF  x99
0372E:  CALL   0EA0
03732:  MOVLW  12
03734:  SUBWF  x60,W
03736:  BNZ   3722
....................    lcd_gotoxy(1,4); printf(lcd_putc,"                  "); 
03738:  MOVLW  01
0373A:  MOVWF  x9A
0373C:  MOVLW  04
0373E:  MOVWF  x9B
03740:  CALL   0E36
03744:  CLRF   x60
03746:  MOVF   x60,W
03748:  CALL   0994
0374C:  INCF   x60,F
0374E:  MOVWF  00
03750:  MOVWF  x99
03752:  CALL   0EA0
03756:  MOVLW  12
03758:  SUBWF  x60,W
0375A:  BNZ   3746
....................     
....................    write_eeprom(10,SPEC.C1h); delay_ms(1); 
0375C:  CLRF   FAA
0375E:  MOVLW  0A
03760:  MOVWF  FA9
03762:  MOVFF  1C,FA8
03766:  BCF    FA6.6
03768:  BCF    FA6.7
0376A:  BSF    FA6.2
0376C:  MOVFF  FF2,00
03770:  BCF    FF2.7
03772:  MOVLB  F
03774:  MOVLW  55
03776:  MOVWF  FA7
03778:  MOVLW  AA
0377A:  MOVWF  FA7
0377C:  BSF    FA6.1
0377E:  BTFSC  FA6.1
03780:  BRA    377E
03782:  BCF    FA6.2
03784:  MOVF   00,W
03786:  IORWF  FF2,F
03788:  MOVLW  01
0378A:  MOVLB  0
0378C:  MOVWF  x9A
0378E:  CALL   0C22
....................    write_eeprom(20,SPEC.C1l); delay_ms(1); 
03792:  CLRF   FAA
03794:  MOVLW  14
03796:  MOVWF  FA9
03798:  MOVFF  1E,FA8
0379C:  BCF    FA6.6
0379E:  BCF    FA6.7
037A0:  BSF    FA6.2
037A2:  MOVFF  FF2,00
037A6:  BCF    FF2.7
037A8:  MOVLB  F
037AA:  MOVLW  55
037AC:  MOVWF  FA7
037AE:  MOVLW  AA
037B0:  MOVWF  FA7
037B2:  BSF    FA6.1
037B4:  BTFSC  FA6.1
037B6:  BRA    37B4
037B8:  BCF    FA6.2
037BA:  MOVF   00,W
037BC:  IORWF  FF2,F
037BE:  MOVLW  01
037C0:  MOVLB  0
037C2:  MOVWF  x9A
037C4:  CALL   0C22
....................    write_eeprom(30,SPEC.C2h); delay_ms(1); 
037C8:  CLRF   FAA
037CA:  MOVLW  1E
037CC:  MOVWF  FA9
037CE:  MOVFF  20,FA8
037D2:  BCF    FA6.6
037D4:  BCF    FA6.7
037D6:  BSF    FA6.2
037D8:  MOVFF  FF2,00
037DC:  BCF    FF2.7
037DE:  MOVLB  F
037E0:  MOVLW  55
037E2:  MOVWF  FA7
037E4:  MOVLW  AA
037E6:  MOVWF  FA7
037E8:  BSF    FA6.1
037EA:  BTFSC  FA6.1
037EC:  BRA    37EA
037EE:  BCF    FA6.2
037F0:  MOVF   00,W
037F2:  IORWF  FF2,F
037F4:  MOVLW  01
037F6:  MOVLB  0
037F8:  MOVWF  x9A
037FA:  CALL   0C22
....................    write_eeprom(40,SPEC.C2l); delay_ms(1); 
037FE:  CLRF   FAA
03800:  MOVLW  28
03802:  MOVWF  FA9
03804:  MOVFF  22,FA8
03808:  BCF    FA6.6
0380A:  BCF    FA6.7
0380C:  BSF    FA6.2
0380E:  MOVFF  FF2,00
03812:  BCF    FF2.7
03814:  MOVLB  F
03816:  MOVLW  55
03818:  MOVWF  FA7
0381A:  MOVLW  AA
0381C:  MOVWF  FA7
0381E:  BSF    FA6.1
03820:  BTFSC  FA6.1
03822:  BRA    3820
03824:  BCF    FA6.2
03826:  MOVF   00,W
03828:  IORWF  FF2,F
0382A:  MOVLW  01
0382C:  MOVLB  0
0382E:  MOVWF  x9A
03830:  CALL   0C22
....................    write_eeprom(50,SPEC.C3h); delay_ms(1); 
03834:  CLRF   FAA
03836:  MOVLW  32
03838:  MOVWF  FA9
0383A:  MOVFF  24,FA8
0383E:  BCF    FA6.6
03840:  BCF    FA6.7
03842:  BSF    FA6.2
03844:  MOVFF  FF2,00
03848:  BCF    FF2.7
0384A:  MOVLB  F
0384C:  MOVLW  55
0384E:  MOVWF  FA7
03850:  MOVLW  AA
03852:  MOVWF  FA7
03854:  BSF    FA6.1
03856:  BTFSC  FA6.1
03858:  BRA    3856
0385A:  BCF    FA6.2
0385C:  MOVF   00,W
0385E:  IORWF  FF2,F
03860:  MOVLW  01
03862:  MOVLB  0
03864:  MOVWF  x9A
03866:  CALL   0C22
....................    write_eeprom(60,SPEC.C3l); delay_ms(1); 
0386A:  CLRF   FAA
0386C:  MOVLW  3C
0386E:  MOVWF  FA9
03870:  MOVFF  26,FA8
03874:  BCF    FA6.6
03876:  BCF    FA6.7
03878:  BSF    FA6.2
0387A:  MOVFF  FF2,00
0387E:  BCF    FF2.7
03880:  MOVLB  F
03882:  MOVLW  55
03884:  MOVWF  FA7
03886:  MOVLW  AA
03888:  MOVWF  FA7
0388A:  BSF    FA6.1
0388C:  BTFSC  FA6.1
0388E:  BRA    388C
03890:  BCF    FA6.2
03892:  MOVF   00,W
03894:  IORWF  FF2,F
03896:  MOVLW  01
03898:  MOVLB  0
0389A:  MOVWF  x9A
0389C:  CALL   0C22
....................     
....................    for(x = 0; x < 3; x++) 
038A0:  CLRF   5E
038A2:  MOVF   5E,W
038A4:  SUBLW  02
038A6:  BNC   3912
....................       { 
....................          for(y = 14; y < 17; y++) 
038A8:  MOVLW  0E
038AA:  MOVWF  5F
038AC:  MOVF   5F,W
038AE:  SUBLW  10
038B0:  BNC   38DA
....................             { 
....................                lcd_gotoxy(y,2); printf(lcd_putc,"."); 
038B2:  MOVFF  5F,9A
038B6:  MOVLW  02
038B8:  MOVWF  x9B
038BA:  CALL   0E36
038BE:  MOVLW  2E
038C0:  MOVWF  x99
038C2:  CALL   0EA0
....................                delay_ms(350); 
038C6:  MOVLW  02
038C8:  MOVWF  x60
038CA:  MOVLW  AF
038CC:  MOVWF  x9A
038CE:  CALL   0C22
038D2:  DECFSZ x60,F
038D4:  BRA    38CA
....................             } 
038D6:  INCF   5F,F
038D8:  BRA    38AC
....................          lcd_gotoxy(14,2); printf(lcd_putc,"       "); 
038DA:  MOVLW  0E
038DC:  MOVWF  x9A
038DE:  MOVLW  02
038E0:  MOVWF  x9B
038E2:  CALL   0E36
038E6:  CLRF   x60
038E8:  MOVF   x60,W
038EA:  CALL   09C6
038EE:  INCF   x60,F
038F0:  MOVWF  00
038F2:  MOVWF  x99
038F4:  CALL   0EA0
038F8:  MOVLW  07
038FA:  SUBWF  x60,W
038FC:  BNZ   38E8
....................          delay_ms(350); 
038FE:  MOVLW  02
03900:  MOVWF  x60
03902:  MOVLW  AF
03904:  MOVWF  x9A
03906:  CALL   0C22
0390A:  DECFSZ x60,F
0390C:  BRA    3902
....................       } 
0390E:  INCF   5E,F
03910:  BRA    38A2
....................     
....................    //Buzzer_Config(); 
....................    lcd_gotoxy(1,3); printf(lcd_putc,"Save is complete... "); 
03912:  MOVLW  01
03914:  MOVWF  x9A
03916:  MOVLW  03
03918:  MOVWF  x9B
0391A:  CALL   0E36
0391E:  CLRF   x60
03920:  MOVF   x60,W
03922:  CALL   09EC
03926:  INCF   x60,F
03928:  MOVWF  00
0392A:  MOVWF  x99
0392C:  CALL   0EA0
03930:  MOVLW  14
03932:  SUBWF  x60,W
03934:  BNZ   3920
....................    lcd_gotoxy(1,4); printf(lcd_putc,"                    "); 
03936:  MOVLW  01
03938:  MOVWF  x9A
0393A:  MOVLW  04
0393C:  MOVWF  x9B
0393E:  CALL   0E36
03942:  CLRF   x60
03944:  MOVF   x60,W
03946:  CALL   01EE
0394A:  INCF   x60,F
0394C:  MOVWF  00
0394E:  MOVWF  x99
03950:  CALL   0EA0
03954:  MOVLW  14
03956:  SUBWF  x60,W
03958:  BNZ   3944
....................    delay_ms(1300); 
0395A:  MOVLW  0A
0395C:  MOVWF  x60
0395E:  MOVLW  82
03960:  MOVWF  x9A
03962:  CALL   0C22
03966:  DECFSZ x60,F
03968:  BRA    395E
.................... } 
0396A:  GOTO   3DE0 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   READ SPEC OF COILS FROM EEPROM 
.................... void Read_SpecCoils(void) 
.................... {   
....................    SPEC.C1h = read_eeprom(10); 
*
011E0:  MOVFF  FF2,5D
011E4:  BCF    FF2.7
011E6:  CLRF   FAA
011E8:  MOVLW  0A
011EA:  MOVWF  FA9
011EC:  BCF    FA6.6
011EE:  BCF    FA6.7
011F0:  BSF    FA6.0
011F2:  MOVF   FA8,W
011F4:  BTFSC  5D.7
011F6:  BSF    FF2.7
011F8:  CLRF   1D
011FA:  MOVWF  1C
....................    SPEC.C1l = read_eeprom(20); 
011FC:  MOVFF  FF2,5D
01200:  BCF    FF2.7
01202:  CLRF   FAA
01204:  MOVLW  14
01206:  MOVWF  FA9
01208:  BCF    FA6.6
0120A:  BCF    FA6.7
0120C:  BSF    FA6.0
0120E:  MOVF   FA8,W
01210:  BTFSC  5D.7
01212:  BSF    FF2.7
01214:  CLRF   1F
01216:  MOVWF  1E
....................    SPEC.C2h = read_eeprom(30); 
01218:  MOVFF  FF2,5D
0121C:  BCF    FF2.7
0121E:  CLRF   FAA
01220:  MOVLW  1E
01222:  MOVWF  FA9
01224:  BCF    FA6.6
01226:  BCF    FA6.7
01228:  BSF    FA6.0
0122A:  MOVF   FA8,W
0122C:  BTFSC  5D.7
0122E:  BSF    FF2.7
01230:  CLRF   21
01232:  MOVWF  20
....................    SPEC.C2l = read_eeprom(40); 
01234:  MOVFF  FF2,5D
01238:  BCF    FF2.7
0123A:  CLRF   FAA
0123C:  MOVLW  28
0123E:  MOVWF  FA9
01240:  BCF    FA6.6
01242:  BCF    FA6.7
01244:  BSF    FA6.0
01246:  MOVF   FA8,W
01248:  BTFSC  5D.7
0124A:  BSF    FF2.7
0124C:  CLRF   23
0124E:  MOVWF  22
....................    SPEC.C3h = read_eeprom(50); 
01250:  MOVFF  FF2,5D
01254:  BCF    FF2.7
01256:  CLRF   FAA
01258:  MOVLW  32
0125A:  MOVWF  FA9
0125C:  BCF    FA6.6
0125E:  BCF    FA6.7
01260:  BSF    FA6.0
01262:  MOVF   FA8,W
01264:  BTFSC  5D.7
01266:  BSF    FF2.7
01268:  CLRF   25
0126A:  MOVWF  24
....................    SPEC.C3l = read_eeprom(60); 
0126C:  MOVFF  FF2,5D
01270:  BCF    FF2.7
01272:  CLRF   FAA
01274:  MOVLW  3C
01276:  MOVWF  FA9
01278:  BCF    FA6.6
0127A:  BCF    FA6.7
0127C:  BSF    FA6.0
0127E:  MOVF   FA8,W
01280:  BTFSC  5D.7
01282:  BSF    FF2.7
01284:  CLRF   27
01286:  MOVWF  26
....................     
....................    lcd_gotoxy(1,2); printf(lcd_putc,"C1H: %03ld  C1L: %03ld  ",SPEC.C1h,SPEC.C1l); 
01288:  MOVLW  01
0128A:  MOVWF  x9A
0128C:  MOVLW  02
0128E:  MOVWF  x9B
01290:  RCALL  0E36
01292:  CLRF   5D
01294:  MOVF   5D,W
01296:  CALL   0884
0129A:  INCF   5D,F
0129C:  MOVWF  00
0129E:  MOVWF  x99
012A0:  RCALL  0EA0
012A2:  MOVLW  05
012A4:  SUBWF  5D,W
012A6:  BNZ   1294
012A8:  MOVLW  0B
012AA:  MOVWF  FE9
012AC:  MOVFF  1D,60
012B0:  MOVFF  1C,5F
012B4:  RCALL  10F6
012B6:  MOVLW  0A
012B8:  MOVWF  5E
012BA:  MOVF   5E,W
012BC:  CALL   0884
012C0:  INCF   5E,F
012C2:  MOVWF  00
012C4:  MOVWF  x99
012C6:  RCALL  0EA0
012C8:  MOVLW  11
012CA:  SUBWF  5E,W
012CC:  BNZ   12BA
012CE:  MOVLW  0B
012D0:  MOVWF  FE9
012D2:  MOVFF  1F,60
012D6:  MOVFF  1E,5F
012DA:  RCALL  10F6
012DC:  MOVLW  20
012DE:  MOVWF  x99
012E0:  RCALL  0EA0
012E2:  MOVLW  20
012E4:  MOVWF  x99
012E6:  RCALL  0EA0
....................    lcd_gotoxy(1,3); printf(lcd_putc,"C2H: %03ld  C2L: %03ld  ",SPEC.C2h,SPEC.C2l); 
012E8:  MOVLW  01
012EA:  MOVWF  x9A
012EC:  MOVLW  03
012EE:  MOVWF  x9B
012F0:  RCALL  0E36
012F2:  CLRF   5D
012F4:  MOVF   5D,W
012F6:  CALL   08BC
012FA:  INCF   5D,F
012FC:  MOVWF  00
012FE:  MOVWF  x99
01300:  RCALL  0EA0
01302:  MOVLW  05
01304:  SUBWF  5D,W
01306:  BNZ   12F4
01308:  MOVLW  0B
0130A:  MOVWF  FE9
0130C:  MOVFF  21,60
01310:  MOVFF  20,5F
01314:  RCALL  10F6
01316:  MOVLW  0A
01318:  MOVWF  5E
0131A:  MOVF   5E,W
0131C:  CALL   08BC
01320:  INCF   5E,F
01322:  MOVWF  00
01324:  MOVWF  x99
01326:  RCALL  0EA0
01328:  MOVLW  11
0132A:  SUBWF  5E,W
0132C:  BNZ   131A
0132E:  MOVLW  0B
01330:  MOVWF  FE9
01332:  MOVFF  23,60
01336:  MOVFF  22,5F
0133A:  RCALL  10F6
0133C:  MOVLW  20
0133E:  MOVWF  x99
01340:  RCALL  0EA0
01342:  MOVLW  20
01344:  MOVWF  x99
01346:  RCALL  0EA0
....................    lcd_gotoxy(1,4); printf(lcd_putc,"C3H: %03ld  C3L: %03ld  ",SPEC.C3h,SPEC.C3l);    
01348:  MOVLW  01
0134A:  MOVWF  x9A
0134C:  MOVLW  04
0134E:  MOVWF  x9B
01350:  RCALL  0E36
01352:  CLRF   5D
01354:  MOVF   5D,W
01356:  CALL   08F4
0135A:  INCF   5D,F
0135C:  MOVWF  00
0135E:  MOVWF  x99
01360:  RCALL  0EA0
01362:  MOVLW  05
01364:  SUBWF  5D,W
01366:  BNZ   1354
01368:  MOVLW  0B
0136A:  MOVWF  FE9
0136C:  MOVFF  25,60
01370:  MOVFF  24,5F
01374:  RCALL  10F6
01376:  MOVLW  0A
01378:  MOVWF  5E
0137A:  MOVF   5E,W
0137C:  CALL   08F4
01380:  INCF   5E,F
01382:  MOVWF  00
01384:  MOVWF  x99
01386:  RCALL  0EA0
01388:  MOVLW  11
0138A:  SUBWF  5E,W
0138C:  BNZ   137A
0138E:  MOVLW  0B
01390:  MOVWF  FE9
01392:  MOVFF  27,60
01396:  MOVFF  26,5F
0139A:  RCALL  10F6
0139C:  MOVLW  20
0139E:  MOVWF  x99
013A0:  RCALL  0EA0
013A2:  MOVLW  20
013A4:  MOVWF  x99
013A6:  RCALL  0EA0
....................         
.................... } 
013A8:  GOTO   1474 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   JUDGEMENT BAUD RATE VALUE FOR INTERFACE BOXC WITH PC 
.................... void JudgeMent_BaudRate(void) 
.................... { 
....................       Rob.Reset_Flag   = FALSE; 
....................       Rob.CompleteSpec = FALSE; 
....................  
....................       lcd_gotoxy(1,1);       printf(lcd_putc,"Pls choose baud rate"); 
....................       for(blink = 0; blink < 3; blink++) 
....................          { 
....................             lcd_gotoxy(1,1); printf(lcd_putc,"                    "); delay_ms(350); 
....................             lcd_gotoxy(1,1); printf(lcd_putc,"Pls choose baud rate"); delay_ms(350); 
....................          } 
....................              
....................             lcd_gotoxy(1,2); printf(lcd_putc,">> 9600             "); 
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   19200            "); 
....................             lcd_gotoxy(1,4); printf(lcd_putc,"   115200           "); delay_ms(10); 
....................             delay_ms(1300); 
....................             while(Rob.CompleteSpec == FALSE)     //-- Wait For JudgeMent Spec To Complete 
....................                { 
....................                   Rob.CompleteSpec = Config_BaudRate();  
....................                }     
....................                 
....................       delay_ms(1200); 
....................       Rob.Reset_Flag   = TRUE; 
....................       Rob.CompleteSpec = FALSE;  
.................... } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SETTING BAUD RATE FOR USE INTERFACE BOXC WITH PC 
.................... boolean Config_BaudRate(void) 
.................... { 
....................   boolean ret    = FALSE; 
....................       sw = GetStatus_SS(SW_ID); 
....................       if(sw == 0xF7)       //--------------- Choose Mode Interface In 9600 
....................          { 
....................             delay_ms(100); 
....................             while(sw == 0xF7) { sw = GetStatus_SS(SW_ID); } 
....................             SPEC.BrSize = 1; 
....................             lcd_gotoxy(1,2); printf(lcd_putc,">> 9600             "); 
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   19200            "); 
....................             lcd_gotoxy(1,4); printf(lcd_putc,"   115200           "); delay_ms(10); 
....................             Buzzer_Beep(); 
....................             ret = FALSE; 
....................          } 
....................           
....................      else if(sw == 0xFB)       //--------------- Choose Mode Interface In 19200 
....................          { 
....................             delay_ms(100); 
....................             while(sw == 0xFB) { sw = GetStatus_SS(SW_ID); } 
....................             SPEC.BrSize = 2; 
....................             lcd_gotoxy(1,2); printf(lcd_putc,"   9600             "); 
....................             lcd_gotoxy(1,3); printf(lcd_putc,">> 19200            "); 
....................             lcd_gotoxy(1,4); printf(lcd_putc,"   115200           "); delay_ms(10); 
....................             Buzzer_Beep(); 
....................             ret = FALSE; 
....................          }   
....................           
....................      else if(sw == 0xFD)       //--------------- Choose Mode Interface In 115200 
....................          { 
....................             delay_ms(100); 
....................             while(sw == 0xFD) { sw = GetStatus_SS(SW_ID); } 
....................             SPEC.BrSize = 3; 
....................             lcd_gotoxy(1,2); printf(lcd_putc,"   9600             "); 
....................             lcd_gotoxy(1,3); printf(lcd_putc,"   19200            "); 
....................             lcd_gotoxy(1,4); printf(lcd_putc,">> 115200           "); delay_ms(10); 
....................             Buzzer_Beep(); 
....................             ret = FALSE; 
....................          } 
....................           
....................     else if(sw == 0xFE) 
....................         { 
....................             delay_ms(150); 
....................             while(sw == 0xFE) { sw = GetStatus_SS(SW_ID); } 
....................             Buzzer_Config(); 
....................             Save_BaudRate(SPEC.BrSize); 
....................             ret = TRUE; 
....................         } 
....................          
....................    return(ret);      
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   SAVE BAUD RATE TO EEPROM 
.................... void Save_BaudRate(byte BR) 
.................... { 
....................    lcd_gotoxy(1,1); printf(lcd_putc,"Save baud rate...   "); 
....................    switch(BR) 
....................    { 
....................       case 1:   
....................                write_eeprom(50,BR);   delay_ms(1); 
....................                #use rs232(baud = 9600, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................       break; 
....................        
....................       case 2:   
....................                write_eeprom(50,BR);   delay_ms(1); 
....................                #use rs232(baud = 19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................       break; 
....................        
....................       case 3:   
....................                write_eeprom(50,BR);   delay_ms(1); 
....................                #use rs232(baud = 115200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................       break; 
....................        
....................       default: 
....................                #use rs232(baud = 19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................    } 
....................     
....................    //Start_Buzzer(); 
....................    delay_ms(2000);    
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   READ BAUD RATE VALUE FROM EEPROM 
.................... void Read_BaudRate(void) 
.................... {    
....................    SPEC.BrSize = read_eeprom(50); 
....................    delay_ms(250); 
....................     
....................    switch(SPEC.BrSize) 
....................    { 
....................       case 1: //----------- READ BAUD RATE 9600 
....................               #use rs232(baud = 9600, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................               lcd_gotoxy(1,2); printf(lcd_putc,"BaudRate: 9600 B/s  "); 
....................       break; 
....................        
....................       case 2: //----------- READ BAUD RATE 19200 
....................               #use rs232(baud = 19200, xmit = TX1, rcv = RX1, BITS = 8, PARITY = N) 
....................               lcd_gotoxy(1,2); printf(lcd_putc,"BaudRate: 19200 B/s "); 
....................       break; 
....................        
....................       case 3: //----------- READ BAUD RATE 115200 
....................               #use rs232(baud = 115200, xmit = TX1, rcv = RX1, BITS  = 8, PARITY = N)  
....................               lcd_gotoxy(1,2); printf(lcd_putc,"BaudRate: 115200 B/s"); 
....................       break;  
....................        
....................       default: 
....................               #use rs232(baud = 19200, xmit = TX1, rcv = RX1, BITS  = 8, PARITY = N)  
....................               lcd_gotoxy(1,2); printf(lcd_putc,"BaudRate: 19200 B/s ");  
....................    } 
....................         
.................... } 
....................  
....................  
.................... //############################################################################\\ 
.................... //####################      Define Parameter       ###########################\\       
....................    char Rcv; 
....................    int8 Cnt_TimeOut;   
....................     
.................... /* 
.................... ************************************************* 
.................... **         Function in use 
.................... ************************************************* 
.................... */ 
....................  
.................... void Rx1_Isr(void); 
.................... void Rx2_Isr(void); 
.................... void Reset_Isr(void); 
.................... void Tim0_Isr(void); 
....................  
.................... void Initial_Port(void); 
.................... void ConfigTimer0(void); 
.................... void Initial_Robot(void); 
.................... void ProcessMode(void); 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   CONFIG TIMER0 
.................... void ConfigTimer0(void) 
.................... {    
....................    setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
*
00C4A:  MOVLW  C7
00C4C:  MOVWF  FD5
....................    set_timer0(0); 
00C4E:  CLRF   FD7
00C50:  CLRF   FD6
.................... } 
00C52:  GOTO   0D52 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   INITIAL CYLINDER 
.................... void Initial_Robot(void) 
.................... { 
....................    Rob.Err_Coil   = 3; 
*
01522:  MOVLW  03
01524:  MOVWF  1A
....................    Rob.ResCoils   = FALSE; 
01526:  BCF    19.5
....................    Rob.ResScrew   = FALSE; 
01528:  BCF    19.6
....................    Rob.ModeI      = 0; 
0152A:  CLRF   1B
....................    Rob.Reset_Flag = FALSE; 
0152C:  BCF    19.0
....................    Rob.Get_Qr     = FALSE; 
0152E:  BCF    19.3
....................     
....................    Rob.CompleteSpec = FALSE; 
01530:  BCF    19.2
....................    Rcv            = '\0'; 
01532:  CLRF   59
....................     
....................    Initial_StageRobot();       
01534:  BRA    0D7C
....................    Clear_Led();          
01536:  RCALL  0E26
....................        
....................    if(Rob.Display_Spec == TRUE) 
01538:  BTFSS  19.1
0153A:  BRA    15B8
....................       {             
....................          lcd_gotoxy(1,1); printf(lcd_putc,"  <<  AFE-3196  >>  "); 
0153C:  MOVLW  01
0153E:  MOVWF  x9A
01540:  MOVWF  x9B
01542:  RCALL  0E36
01544:  CLRF   5D
01546:  MOVF   5D,W
01548:  CALL   0A20
0154C:  INCF   5D,F
0154E:  MOVWF  00
01550:  MOVWF  x99
01552:  RCALL  0EA0
01554:  MOVLW  14
01556:  SUBWF  5D,W
01558:  BNZ   1546
....................          lcd_gotoxy(1,2); printf(lcd_putc,"   FS120829-2.1.2   "); 
0155A:  MOVLW  01
0155C:  MOVWF  x9A
0155E:  MOVLW  02
01560:  MOVWF  x9B
01562:  RCALL  0E36
01564:  CLRF   5D
01566:  MOVF   5D,W
01568:  CALL   0A54
0156C:  INCF   5D,F
0156E:  MOVWF  00
01570:  MOVWF  x99
01572:  RCALL  0EA0
01574:  MOVLW  14
01576:  SUBWF  5D,W
01578:  BNZ   1566
....................          delay_ms(2000); 
0157A:  MOVLW  08
0157C:  MOVWF  5D
0157E:  MOVLW  FA
01580:  MOVWF  x9A
01582:  CALL   0C22
01586:  DECFSZ 5D,F
01588:  BRA    157E
....................           
....................          Check_InterFace(); 
0158A:  RCALL  13AC
....................          printf("MACHINE START\r"); 
0158C:  CLRF   5D
0158E:  MOVF   5D,W
01590:  CALL   0A88
01594:  INCF   5D,F
01596:  MOVWF  00
01598:  MOVF   00,W
0159A:  BTFSS  F9E.4
0159C:  BRA    159A
0159E:  MOVWF  FAD
015A0:  MOVLW  0E
015A2:  SUBWF  5D,W
015A4:  BNZ   158E
....................          delay_ms(2000); 
015A6:  MOVLW  08
015A8:  MOVWF  5D
015AA:  MOVLW  FA
015AC:  MOVWF  x9A
015AE:  CALL   0C22
015B2:  DECFSZ 5D,F
015B4:  BRA    15AA
....................          Rob.Display_Spec = FALSE; 
015B6:  BCF    19.1
....................       } 
....................        
....................    Diplay_Ready(); 
015B8:  BRA    1476
....................    Start_Buzzer(); 
015BA:  RCALL  1500
....................     
.................... } 
015BC:  GOTO   48F2 (RETURN)
....................  
....................  
.................... //****************************************************************************** 
.................... //****************  CLEAR STAGE OF ROBOT TO INITIAL 
.................... void Initial_Port(void) 
.................... { 
....................    Cnt_TimeOut = 0; 
*
00D2A:  CLRF   5A
....................    output_high(SV_COILS);  output_high(SV_STAMP);  
00D2C:  BCF    F95.4
00D2E:  BSF    F8C.4
00D30:  BCF    F95.2
00D32:  BSF    F8C.2
....................    output_high(SV_LOCK);   output_high(SV_QR);   output_high(SV_SCREW); 
00D34:  BCF    F95.1
00D36:  BSF    F8C.1
00D38:  BCF    F95.3
00D3A:  BSF    F8C.3
00D3C:  BCF    F95.5
00D3E:  BSF    F8C.5
....................    output_high(SV_SLIDER); delay_ms(200); 
00D40:  BCF    F95.0
00D42:  BSF    F8C.0
00D44:  MOVLW  C8
00D46:  MOVWF  x9A
00D48:  RCALL  0C22
....................    output_high(BUZZER);    output_high(LEDG);    output_high(LEDR); 
00D4A:  BSF    F8D.1
00D4C:  BSF    F8D.2
00D4E:  BSF    F8D.3
....................     
....................    ConfigTimer0(); 
00D50:  BRA    0C4A
....................    setup_adc_ports(AN0_TO_AN2|VSS_VDD); 
00D52:  MOVF   FC1,W
00D54:  ANDLW  C0
00D56:  IORLW  0C
00D58:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL); 
00D5A:  BSF    FC0.0
00D5C:  BSF    FC0.1
00D5E:  BSF    FC0.2
00D60:  BSF    FC0.7
00D62:  BSF    FC2.0
....................    output_low(RELAY); 
00D64:  BCF    F89.3
....................     
....................    lcd_init(); 
00D66:  BRA    0CCC
....................    delay_ms(500); 
00D68:  MOVLW  02
00D6A:  MOVWF  5D
00D6C:  MOVLW  FA
00D6E:  MOVWF  x9A
00D70:  RCALL  0C22
00D72:  DECFSZ 5D,F
00D74:  BRA    0D6C
....................    Initial_SenSor();    
00D76:  BRA    0D24
.................... } 
00D78:  GOTO   48EE (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //-------------------   
.................... void ProcessMode(void) 
.................... {    
....................    if(!input(SW_START))       //-- AUTO FOR ALL PROCESS (CHECK COILS,SCREW AND QR CODE). 
*
0467C:  BTFSC  F81.1
0467E:  BRA    4798
....................     { 
....................       delay_ms(200); 
04680:  MOVLW  C8
04682:  MOVWF  x9A
04684:  CALL   0C22
....................       while(!input(SW_START)); 
04688:  BTFSS  F81.1
0468A:  BRA    4688
....................          Clear_LCD(); 
0468C:  CALL   0EE4
....................          Clear_Led(); 
04690:  CALL   0E26
....................          if( (!input(SS_COIL_UP)) && (input(SS_SCREW_UP)) && (!input(SS_QR_UP)) &&  
....................            (!input(SS_UNLOCK)) && (!input(SS_STAMP_UP)) && (!input(SS_L)) ) 
04694:  BTFSC  F86.0
04696:  BRA    478A
04698:  BTFSS  F86.3
0469A:  BRA    478A
0469C:  BTFSC  F82.2
0469E:  BRA    478A
046A0:  BTFSC  F81.3
046A2:  BRA    478A
046A4:  BTFSC  F81.5
046A6:  BRA    478A
046A8:  BTFSC  F85.0
046AA:  BRA    478A
....................           { 
....................                sw = GetStatus_SS(SW_ID); 
046AC:  MOVLW  70
046AE:  MOVWF  5E
046B0:  CALL   10AC
046B4:  MOVFF  01,2A
....................                delay_ms(200); 
046B8:  MOVLW  C8
046BA:  MOVWF  x9A
046BC:  CALL   0C22
....................                if(sw == 0xFF)          //  --ALL 
046C0:  INCFSZ 2A,W
046C2:  BRA    46D2
....................                   { 
....................                      delay_ms(200); 
046C4:  MOVLW  C8
046C6:  MOVWF  x9A
046C8:  CALL   0C22
....................                      Rob.ModeI = 2; 
046CC:  MOVLW  02
046CE:  MOVWF  1B
....................                   } 
....................                 
....................                else if(sw == 0xFB)    //  --Chk&Stm 
046D0:  BRA    46F8
046D2:  MOVF   2A,W
046D4:  SUBLW  FB
046D6:  BNZ   46E6
....................                   { 
....................                      delay_ms(200); 
046D8:  MOVLW  C8
046DA:  MOVWF  x9A
046DC:  CALL   0C22
....................                      Rob.ModeI = 3; 
046E0:  MOVLW  03
046E2:  MOVWF  1B
....................                   } 
....................                    
....................                else if(sw == 0xF9)    //   --Stamp Only 
046E4:  BRA    46F8
046E6:  MOVF   2A,W
046E8:  SUBLW  F9
046EA:  BNZ   46F8
....................                    { 
....................                      delay_ms(200); 
046EC:  MOVLW  C8
046EE:  MOVWF  x9A
046F0:  CALL   0C22
....................                      Rob.ModeI = 4; 
046F4:  MOVLW  04
046F6:  MOVWF  1B
....................                   } 
....................                    
....................                    
....................                switch(Rob.ModeI) 
....................                { 
046F8:  MOVLW  01
046FA:  SUBWF  1B,W
046FC:  ADDLW  FC
046FE:  BC    4788
04700:  ADDLW  04
04702:  GOTO   47A6
....................                   case 1: 
....................                           Rob.ModeI = 0; 
04706:  CLRF   1B
....................                           Config_Type(); 
04708:  RCALL  3F9C
....................                           //printf(" Config Type \n"); 
....................                   break; 
0470A:  BRA    4788
....................                    
....................                   case 2: 
....................                           Rob.ModeI = 0; 
0470C:  CLRF   1B
....................                           lcd_gotoxy(1,2); printf(lcd_putc,"Check...           "); 
0470E:  MOVLW  01
04710:  MOVWF  x9A
04712:  MOVLW  02
04714:  MOVWF  x9B
04716:  CALL   0E36
0471A:  CLRF   5D
0471C:  MOVF   5D,W
0471E:  CALL   0AB6
04722:  INCF   5D,F
04724:  MOVWF  00
04726:  MOVWF  x99
04728:  CALL   0EA0
0472C:  MOVLW  13
0472E:  SUBWF  5D,W
04730:  BNZ   471C
....................                           OperateAll(); 
04732:  BRA    45CE
....................                           //printf(" Check All Process \n"); 
....................                   break; 
....................                             
....................                   case 3: 
....................                           Rob.ModeI = 0; 
04734:  CLRF   1B
....................                           lcd_gotoxy(1,2); printf(lcd_putc,"Check...           "); 
04736:  MOVLW  01
04738:  MOVWF  x9A
0473A:  MOVLW  02
0473C:  MOVWF  x9B
0473E:  CALL   0E36
04742:  CLRF   5D
04744:  MOVF   5D,W
04746:  CALL   0AB6
0474A:  INCF   5D,F
0474C:  MOVWF  00
0474E:  MOVWF  x99
04750:  CALL   0EA0
04754:  MOVLW  13
04756:  SUBWF  5D,W
04758:  BNZ   4744
....................                           Check_R_Stamp();    
0475A:  RCALL  4572
....................                           //printf(" Check & Stamping But No QR \n"); 
....................                   break; 
0475C:  BRA    4788
....................                             
....................                   case 4: 
....................                           Rob.ModeI = 0; 
0475E:  CLRF   1B
....................                           lcd_gotoxy(1,2); printf(lcd_putc,"Check...           "); 
04760:  MOVLW  01
04762:  MOVWF  x9A
04764:  MOVLW  02
04766:  MOVWF  x9B
04768:  CALL   0E36
0476C:  CLRF   5D
0476E:  MOVF   5D,W
04770:  CALL   0AB6
04774:  INCF   5D,F
04776:  MOVWF  00
04778:  MOVWF  x99
0477A:  CALL   0EA0
0477E:  MOVLW  13
04780:  SUBWF  5D,W
04782:  BNZ   476E
....................                           StampOnly();   
04784:  RCALL  44D6
....................                          // printf(" Stamping Only \n"); 
....................                   break;  
04786:  BRA    4788
....................                }                   
....................           } 
....................         
....................         else 
04788:  BRA    4796
....................          { 
....................              Display_CylinderError(); 
0478A:  CALL   15C0
....................              Buzzer_Alarm(10); 
0478E:  MOVLW  0A
04790:  MOVWF  x8D
04792:  CALL   1618
....................          }   
....................         //Clear_LCD();  
....................        // Resistance3();  
....................           
....................           
....................     } 
....................      
....................   else if(Rob.ModeI == 1) 
04796:  BRA    47A2
04798:  DECFSZ 1B,W
0479A:  BRA    47A2
....................    { 
....................          Rob.ModeI = 0; 
0479C:  CLRF   1B
....................          Config_Type(); 
0479E:  CALL   3F9C
....................    } 
....................     
....................     
....................  /* else if(Rob.Ack_Qr) 
....................     { 
....................          Rob.Ack_Qr = FALSE; 
....................          printf("%s",QR_Packet); 
....................        
....................          lcd_gotoxy(1,2); printf(lcd_putc,"QR Code :           "); 
....................          lcd_gotoxy(1,3); printf(lcd_putc,"%s               ",Qr_Show); 
....................     } 
....................           
....................   else if(Rob.Get_Qr) 
....................     { 
....................          Rob.Get_Qr = FALSE; 
....................          LED_GREEN(); delay_ms(10); 
....................          //Clear_Led(); 
....................          lcd_gotoxy(1,4); printf(lcd_putc,"Data is OK...       "); 
....................     } */  
....................      
.................... } 
047A2:  GOTO   48F8 (RETURN)
....................  
....................  
.................... //**  SETUP INTERRUPT PRIORITY LEVEL 
.................... #PRIORITY RDA,RDA2,TIMER0,EXT 
....................  
.................... //############################################################################\\ 
.................... //-----------  INTERRUPT ON RECIEVER1 CHANNEL (RX1) 
.................... #INT_RDA 
.................... void Rx1_Isr(void) 
.................... {         
....................    static enum _Sequence  
....................       { 
....................          first, 
....................          second 
....................       } Sequence = first; 
....................        
....................    Rcv = getc1USART(); 
*
00B1A:  BRA    0B0E
00B1C:  MOVFF  01,59
....................     
....................    switch(Sequence) 
....................       { 
00B20:  MOVLW  00
00B22:  BTFSC  5B.0
00B24:  MOVLW  01
00B26:  XORLW  00
00B28:  BZ    0B30
00B2A:  XORLW  01
00B2C:  BZ    0B4E
00B2E:  BRA    0B76
....................          case first: 
....................                      //output_toggle(PIN_H0); 
....................                      if((Rcv == 'O') || (Rcv == 'N') || (Rcv == 'R')) 
00B30:  MOVF   59,W
00B32:  SUBLW  4F
00B34:  BZ    0B42
00B36:  MOVF   59,W
00B38:  SUBLW  4E
00B3A:  BZ    0B42
00B3C:  MOVF   59,W
00B3E:  SUBLW  52
00B40:  BNZ   0B46
....................                            Sequence = second; 
00B42:  BSF    5B.0
....................                          
....................                      else 
00B44:  BRA    0B4C
....................                         { 
....................                            Rob.Get_Qr  = FALSE; 
00B46:  BCF    19.3
....................                            Sequence    = first; 
00B48:  BCF    5B.0
....................                            Rcv         = '\0'; 
00B4A:  CLRF   59
....................                         }       
....................          break; 
00B4C:  BRA    0B76
....................           
....................          case second: 
....................                      //output_toggle(PIN_H0); 
....................                      switch(Rcv) 
....................                         { 
00B4E:  MOVF   59,W
00B50:  XORLW  4B
00B52:  BZ    0B5A
00B54:  XORLW  0C
00B56:  BZ    0B64
00B58:  BRA    0B6C
....................                            case 'K':  
....................                                        output_low(LEDG); 
00B5A:  BCF    F8D.2
....................                                        Rob.Get_Qr  = TRUE; 
00B5C:  BSF    19.3
....................                                        Sequence    = first; 
00B5E:  BCF    5B.0
....................                                        Rcv         = '\0'; 
00B60:  CLRF   59
....................                            break; 
00B62:  BRA    0B74
....................                             
....................                            case 'G': 
....................                                        Rob.Get_Qr  = FALSE; 
00B64:  BCF    19.3
....................                                        Sequence    = first; 
00B66:  BCF    5B.0
....................                                        Rcv         = '\0';  
00B68:  CLRF   59
....................                            break; 
00B6A:  BRA    0B74
....................                             
....................                            default:    Rob.Get_Qr  = FALSE; 
00B6C:  BCF    19.3
....................                                        Sequence    = first; 
00B6E:  BCF    5B.0
....................                                        Rcv         = '\0';  
00B70:  CLRF   59
....................                            break; 
00B72:  BRA    0B74
....................                         } 
....................          break; 
00B74:  BRA    0B76
....................  
....................       } 
....................     //output_toggle(PIN_H0);  
.................... } 
....................  
....................  
.................... //############################################################################\\ 
.................... //-----------  INTERRUPT ON RECIEVER2 CHANNEL (RX2) 
00B76:  BCF    F9E.5
00B78:  GOTO   0080
.................... #INT_RDA2 
.................... void Rx2_Isr(void) 
.................... {         
....................    static int cnt_add = 0; 
....................    char Rcv2 = '\0'; 
*
00B88:  CLRF   xB1
....................        
....................    Rcv2 = getc2USART(); 
00B8A:  BRA    0B7C
00B8C:  MOVFF  01,B1
....................    //output_toggle(LEDG);  
....................  
....................    if(Rcv2 != '\r') 
00B90:  MOVF   xB1,W
00B92:  SUBLW  0D
00B94:  BZ    0BDC
....................       { 
....................          QR_Packet[cnt_add] = Rcv2; 
00B96:  CLRF   03
00B98:  MOVF   5C,W
00B9A:  ADDLW  2B
00B9C:  MOVWF  FE9
00B9E:  MOVLW  00
00BA0:  ADDWFC 03,W
00BA2:  MOVWF  FEA
00BA4:  MOVFF  B1,FEF
....................          Qr_Show[cnt_add]   = QR_Packet[cnt_add]; 
00BA8:  CLRF   03
00BAA:  MOVF   5C,W
00BAC:  ADDLW  3F
00BAE:  MOVWF  01
00BB0:  MOVLW  00
00BB2:  ADDWFC 03,F
00BB4:  MOVFF  03,B3
00BB8:  CLRF   03
00BBA:  MOVF   5C,W
00BBC:  ADDLW  2B
00BBE:  MOVWF  FE9
00BC0:  MOVLW  00
00BC2:  ADDWFC 03,W
00BC4:  MOVWF  FEA
00BC6:  MOVFF  FEF,B4
00BCA:  MOVFF  B3,FEA
00BCE:  MOVFF  01,FE9
00BD2:  MOVFF  B4,FEF
....................          cnt_add++; 
00BD6:  INCF   5C,F
....................          Rob.Ack_Qr         = FALSE; 
00BD8:  BCF    19.4
....................       } 
....................        
....................    else 
00BDA:  BRA    0BF2
....................       {          
....................          QR_Packet[cnt_add] = '\r'; 
00BDC:  CLRF   03
00BDE:  MOVF   5C,W
00BE0:  ADDLW  2B
00BE2:  MOVWF  FE9
00BE4:  MOVLW  00
00BE6:  ADDWFC 03,W
00BE8:  MOVWF  FEA
00BEA:  MOVLW  0D
00BEC:  MOVWF  FEF
....................          cnt_add    = 0; 
00BEE:  CLRF   5C
....................          Rob.Ack_Qr = TRUE;          
00BF0:  BSF    19.4
....................       } 
....................     
.................... } 
....................  
....................  
....................  
.................... //############################################################################\\ 
.................... //-----------  INTERRUPT ON TIMER0 
00BF2:  BCF    FA4.5
00BF4:  GOTO   0080
.................... #INT_TIMER0 
.................... void Tim0_Isr(void) 
.................... { 
....................    Cnt_TimeOut++; 
00BF8:  INCF   5A,F
....................    if(Cnt_TimeOut >= 83) 
00BFA:  MOVF   5A,W
00BFC:  SUBLW  52
00BFE:  BC    0C06
....................       { 
....................          Cnt_TimeOut = 0; 
00C00:  CLRF   5A
....................          output_toggle(LED_START); 
00C02:  BCF    F95.7
00C04:  BTG    F8C.7
....................       } 
.................... } 
....................  
.................... //############################################################################\\ 
.................... //-----------  INTERRUPT ON EXTERNAL 
00C06:  BCF    FF2.2
00C08:  GOTO   0080
.................... #INT_EXT 
.................... void Reset_Isr(void)  
.................... { 
....................    delay_us(20); 
00C0C:  MOVLW  42
00C0E:  MOVWF  00
00C10:  DECFSZ 00,F
00C12:  BRA    0C10
00C14:  NOP   
....................    while(!input(PIN_B0)); 
00C16:  BTFSS  F81.0
00C18:  BRA    0C16
....................    Rob.Reset_Flag = TRUE; 
00C1A:  BSF    19.0
.................... } 
....................  
....................  
.................... //############################################################################\\ 
.................... //        _________________      MAIN FUNCTION       __________________       \\ 
.................... //############################################################################\\ 
00C1C:  BCF    FF2.1
00C1E:  GOTO   0080
.................... void main(void) 
.................... {                                        
*
047E4:  CLRF   FF8
047E6:  BCF    FD0.7
047E8:  BSF    0D.7
047EA:  CLRF   FEA
047EC:  CLRF   FE9
047EE:  MOVLW  81
047F0:  MOVWF  FAF
047F2:  MOVLW  A6
047F4:  MOVWF  FAC
047F6:  MOVLW  90
047F8:  MOVWF  FAB
047FA:  MOVLW  81
047FC:  MOVWF  FAF
047FE:  MOVLW  A6
04800:  MOVWF  FAC
04802:  MOVLW  90
04804:  MOVWF  FAB
04806:  MOVLW  81
04808:  MOVWF  FAF
0480A:  MOVLW  A6
0480C:  MOVWF  FAC
0480E:  MOVLW  90
04810:  MOVWF  FAB
04812:  MOVLW  81
04814:  MOVWF  FAF
04816:  MOVLW  A6
04818:  MOVWF  FAC
0481A:  MOVLW  90
0481C:  MOVWF  FAB
0481E:  MOVLW  40
04820:  MOVWF  F6F
04822:  MOVLW  A6
04824:  MOVWF  F6C
04826:  MOVLW  90
04828:  MOVWF  F6B
0482A:  MOVLW  40
0482C:  MOVWF  F6F
0482E:  MOVLW  A6
04830:  MOVWF  F6C
04832:  MOVLW  90
04834:  MOVWF  F6B
04836:  MOVLW  40
04838:  MOVWF  FAF
0483A:  MOVLW  A6
0483C:  MOVWF  FAC
0483E:  MOVLW  90
04840:  MOVWF  FAB
04842:  MOVLW  40
04844:  MOVWF  FAF
04846:  MOVLW  A2
04848:  MOVWF  FAC
0484A:  MOVLW  90
0484C:  MOVWF  FAB
0484E:  MOVLW  81
04850:  MOVWF  FAF
04852:  MOVLW  A6
04854:  MOVWF  FAC
04856:  MOVLW  90
04858:  MOVWF  FAB
0485A:  MOVLW  15
0485C:  MOVWF  FAF
0485E:  MOVLW  A6
04860:  MOVWF  FAC
04862:  MOVLW  90
04864:  MOVWF  FAB
04866:  MOVLW  81
04868:  MOVWF  FAF
0486A:  MOVLW  A6
0486C:  MOVWF  FAC
0486E:  MOVLW  90
04870:  MOVWF  FAB
04872:  MOVLW  40
04874:  MOVWF  FAF
04876:  MOVLW  A2
04878:  MOVWF  FAC
0487A:  MOVLW  90
0487C:  MOVWF  FAB
0487E:  MOVLW  81
04880:  MOVWF  FAF
04882:  MOVLW  A6
04884:  MOVWF  FAC
04886:  MOVLW  90
04888:  MOVWF  FAB
0488A:  MOVLW  15
0488C:  MOVWF  FAF
0488E:  MOVLW  A6
04890:  MOVWF  FAC
04892:  MOVLW  90
04894:  MOVWF  FAB
04896:  MOVLW  81
04898:  MOVWF  FAF
0489A:  MOVLW  A6
0489C:  MOVWF  FAC
0489E:  MOVLW  90
048A0:  MOVWF  FAB
048A2:  MOVF   FC1,W
048A4:  ANDLW  C0
048A6:  IORLW  0F
048A8:  MOVWF  FC1
048AA:  MOVLW  07
048AC:  MOVWF  FB4
048AE:  CLRF   53
048B0:  CLRF   54
048B2:  MOVLW  01
048B4:  MOVWF  58
048B6:  BCF    5B.0
048B8:  CLRF   5C
....................    enable_interrupts(GLOBAL); 
048BA:  MOVLW  C0
048BC:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
048BE:  BSF    F9D.5
....................    enable_interrupts(INT_RDA2); 
048C0:  BSF    FA3.5
....................    enable_interrupts(INT_TIMER0); 
048C2:  BSF    FF2.5
....................    enable_interrupts(INT_EXT); 
048C4:  BSF    FF2.4
....................    EXT_INT_EDGE(H_TO_L); 
048C6:  BCF    FF1.6
....................     
....................    set_tris_a(0b11100111);    
048C8:  MOVLW  E7
048CA:  MOVWF  F92
....................    set_tris_b(0b00111111);   
048CC:  MOVLW  3F
048CE:  MOVWF  F93
....................    set_tris_c(0b10000110); 
048D0:  MOVLW  86
048D2:  MOVWF  F94
....................    set_tris_d(0b00000000);    
048D4:  MOVLW  00
048D6:  MOVWF  F95
....................    set_tris_e(0b10000000);    
048D8:  MOVLW  80
048DA:  MOVWF  F96
....................    set_tris_f(0b11111111); 
048DC:  MOVLW  FF
048DE:  MOVWF  F97
....................    set_tris_g(0b00011101); 
048E0:  MOVLW  1D
048E2:  MOVWF  F98
....................    set_tris_h(0b00000000); 
048E4:  MOVLW  00
048E6:  MOVWF  F99
....................    set_tris_j(0b00000000); 
048E8:  MOVWF  F9A
....................     
....................    Initial_Port();  
048EA:  GOTO   0D2A
....................  
....................    Init_Rob: 
....................       Initial_Robot();              
048EE:  GOTO   1522
....................   
....................    while(TRUE)              
....................    { 
....................      //SV_STAMP 
....................      _StatusIO_();  //output_toggle(RELAY); delay_ms(700); 
048F2:  GOTO   2F3E
....................       ProcessMode(); 
048F6:  BRA    467C
....................  
....................       if(Rob.Reset_Flag == TRUE) 
048F8:  BTFSS  19.0
048FA:  BRA    4924
....................          { 
....................             delay_ms(500); 
048FC:  MOVLW  02
048FE:  MOVWF  5D
04900:  MOVLW  FA
04902:  MOVWF  x9A
04904:  CALL   0C22
04908:  DECFSZ 5D,F
0490A:  BRA    4900
....................             Rob.Reset_Flag = FALSE; 
0490C:  BCF    19.0
....................             putc1USART("RESET\r"); 
0490E:  CLRF   5D
04910:  MOVF   5D,W
04912:  CALL   0AE8
04916:  IORLW  00
04918:  BZ    4922
0491A:  INCF   5D,F
0491C:  MOVWF  5E
0491E:  BRA    47D8
04920:  BRA    4910
....................             GOTO Init_Rob; 
04922:  BRA    48EE
....................          } 
....................       //output_d(0x00); delay_ms(500); 
....................       //output_d(0xff); delay_ms(500); 
....................       /*else if(!input(SS_SCREW4)) 
....................       { 
....................          delay_ms(500); 
....................          output_toggle(LEDG); 
....................       }*/ 
....................    }  
04924:  BRA    48F2
.................... } 
.................... //                         ^-^     ^-^     ^-^ 
.................... //####################       < End Program >         #########################// 
04926:  SLEEP 

Configuration Fuses:
   Word  1: 2600   H4 NOOSCSEN
   Word  2: 0E01   NOBROWNOUT WDT128 NOWDT BORV45 NOPUT
   Word  3: 0183   NOWAIT MCU CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C0FF   NOPROTECT NOCPD NOCPB
   Word  6: E0FF   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 40FF   NOEBTR NOEBTRB
